<HTML>  <HEAD>  <META NAME="GENERATOR" CONTENT="Adobe PageMill 3.0 Mac">  <TITLE>NIH Image Macros - An Introduction</TITLE></HEAD><BODY LINK="#0000ff"><P><A NAME="anchor290977"></A><B><TT><FONT FACE="Courier">NIHImage Macros - An Introduction<BR></FONT></TT></B><FONT FACE="Courier">v. 1.0a<BR><BR>Michael J. Green<BR><BR>Department of Geological Sciences<BR>University College London<BR><BR><A HREF="mailto:michael.green@ucl.ac.uk">michael.green@ucl.ac.uk</A></FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR><BR>Contents<BR><BR></FONT></TT><FONT FACE="Courier"><A HREF="#anchor300400">1. Aboutthis manual</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor300831">2. Introduction tomacros</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor301893">3. Variables</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor302455">4. Decimals, powers,and text output</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor303060">5. Functions andprocedures</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor303746">6. For loops</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor304297">7. If statements</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor305217">8. Repeat and whileloops</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor305769">9. Arrays</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor306408">10. Introductionto image measurement</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor307304">11. Introductionto image processing</A></FONT><BR><FONT FACE="Courier"><A HREF="#anchor308372">12. Where next?</A><TT><BR><BR>The information in this manual is free. It may be copied, distributedand/or modified under the conditions set down in the Design ScienceLicense published by Michael Stutz at </TT><A HREF="http://dsl.org/copyleft/dsl.txt">http://dsl.org/copyleft/dsl.txt</A><TT>.</TT></FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><FONT FACE="Courier"><BR><BR></FONT><A NAME="anchor300400"></A><B><TT><FONT FACE="Courier">1.About this manual</FONT></TT></B><FONT FACE="Courier"><BR><BR>1.1 Prerequisites<BR><BR>The reader is assumed to be familiar with the basic operationsof NIH Image (loading, saving, and processing of images, etc).but not with the use of macros. You'll need a recent version ofNIH Image (e.g. version 1.62, 1999), and the example macros thatcome with it.<BR><BR><BR>1.2 Target audience<BR><BR>Anyone who wants to write macros for NIH Image but has no computerprogramming experience, or just anyone who uses NIH Image a lotand is looking for ways to use it more efficiently.<BR><BR><BR>1.3 Aims<BR><BR>The aim of this manual is not just to teach the &quot;basics&quot;of macro writing, but also to give the reader confidence to goto higher-level manuals and learn more complex things. For someonewith no prior experience of programming, working through thismanual should take about two weeks. Since the NIH Image macrolanguage is based on the language Pascal, then anyone with someexperience of Pascal will get up to speed much faster. But bearin mind that there are some major differences between &quot;proper&quot;Pascal and the NIH Image macro language, and to write NIH Imagemacros it is useful to have a specific manual.<BR><BR>This manual gives a thorough coverage of the basics of macro writingand is therefore very limited in scope. But it is this &quot;nutsand bolts&quot; knowledge which makes writing more complex macrosin the future much easier. No prior knowledge of computer programmingis assumed, and it is written at a level which is deliberately&quot;accessible to all&quot; even at the price of appearing toosimple for some. In this respect it is different from the othermanuals available which cover NIH Image macros, all of which assumesome knowledge of Pascal and are generally pitched at a levelthat is too hard for the beginner. Its basis is a large numberof simple macros, all of which are fully tested.<BR><BR>This manual will not make you an expert in NIH Image macro programming,though it is a useful first step. It also won't teach you verymuch about image analysis.<BR><BR><BR>1.4 Other useful documents<BR><BR>Two essential documents that you need can be downloaded from theNIH Image home page at <A HREF="http://rsb.info.nih.gov/nih-image/">http://rsb.info.nih.gov/nih-image/</A><TT>.These are the Online Manual, which gives a good general overviewof everything NIH Image does (though like I say, the macros section- Appendix A - is pretty hard going for non-programmers) and thelist of Macro Commands, which is available under &quot;More Documentation&quot;.By all means download Mark Vivino's &quot;Inside NIH Image&quot;from there too, but if you can write macros with it as your onlyguide, then you don't need to be reading this.<BR><BR><BR>1.5 What macros do<BR><BR>Macros let you automate NIH Image, so that you can repeat thesame list of operations many times. This can be a huge time saverwhen you have a long list of images to process, and easily repaysthe time spent learning to write macros. Macros also give youvirtually unlimited scope for extending what you can do with NIHImage, letting you develop your own tools for image measurementand image processing. In this sense, macros basically let youdo lots of things with NIH Image that you didn't think it coulddo. The only limit is your ingenuity.<BR><BR><BR>1.6 Manual structure in brief<BR><BR>After the introduction, we spend two chapters looking at variables,one looking at structured programming, and then another threeworking through the basic commands of the macro language (whichare taken from Pascal). At this point, the reader should be ableto write basic Pascal programs as well as basic macros. We thenspend three chapters concentrating more on the specifics of imageanalysis in NIH Image. The final chapter covers where to go next,for more information.<BR><BR><BR>1.7 Two important questions<BR><BR>These are so important that I'll put them in now. Say you areconsidering writing a macro. First: is it really needed? As in,is there already a command in NIH Image that does the same thing,that you've overlooked? For example, there's no point writinga macro to threshold an image into black and white - NIH Imagecan already do this. Second: has someone else already writtenthis macro? Most people use NIH Image for the same kind of things,run into the same kind of problems, and write the same kind ofmacros to fix them. Check the macros you already have, and checkother people you know who use NIH Image, and check the NIH Imagemailing list (available at </TT><A HREF="http://list.nih.gov/archives/nih-image.html">http://list.nih.gov/archives/nih-image.html</A><TT>).Maybe someone else already solved your problem. (On the otherhand, if it's a simple one, why not write the macro anyway asan exercise - keep your brain in gear?)</TT></FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor300831"></A><B><TT><FONT FACE="Courier">2.Introduction to macros</FONT></TT></B><TT><FONT FACE="Courier"><BR><BR>2.1 Creating a new macro<BR><BR>Load up NIH Image, then click &quot;File&quot;, then &quot;New&quot;,and you get a dialogue box; click the &quot;Text Window&quot;radio button in the top right hand corner (don't worry about thesize or the title for now). This creates a new text window whereyou can enter your macro(s). Actually, you can put any text youlike into an NIH Image text window - it's just like a simple wordprocessor. Text files can be saved and loaded using the &quot;File&quot;menu. They appear on the desktop with an NIH-Image-specific &quot;TEXT&quot;icon.<BR><BR><BR>2.2 Basic macro structure<BR><BR>All macros look like this:<BR><BR>macro 'Do Nothing';<BR>begin<BR>end;<BR><BR>Here, &quot;Do Nothing&quot; is the title of the macro, and the&quot;begin ... end;&quot; bit marks where the macro commandsactually go. Note the semicolons - these are &quot;statement terminators&quot;.We'll look at these in more detail later - for now, be aware thatif they are missing, the macro will crash.<BR><BR><BR>2.3 Comments<BR><BR>Comments - which are ignored by the computer - can be insertedinto macros between curly brackets {}. These are essential inmore complex macro programming, to help the programmer keep trackof where he is at. They can be spread over more than one line,as long as there is a closing bracket there somewhere.<BR><BR>macro 'Just Comments';<BR>begin<BR>&nbsp; &nbsp; &nbsp; {This is a comment}<BR>end;<BR><BR>macro 'Just Comments 2';<BR>begin<BR>&nbsp; &nbsp; &nbsp; {This is a comment<BR>&nbsp; &nbsp; &nbsp; it continues here...<BR>&nbsp; &nbsp; &nbsp; and here.}<BR>end;<BR><BR><BR>2.4 A simple macro<BR><BR>Now for a macro which actually does something. When it is run,it waits until the user presses the mouse button, then beeps.(Don't worry about the details of these commands for now).<BR><BR>macro 'Beep After Click';<BR>begin<BR>&nbsp; &nbsp; &nbsp; repeat until button;<BR>&nbsp; &nbsp; &nbsp; Beep;<BR>end;<BR><BR><BR>2.5 Loading and running macros<BR><BR>Typing in any of the above macros and saving them results in a&quot;TEXT&quot; file, which can be double-clicked (or loadedusing the &quot;File&quot; menu) to bring it back into NIH Imagefor more editing. But to actually run any macro, we have to &quot;load&quot;it in a different way. To edit a macro, you load it as above,as a text file. But to run a macro, you have to load it into the&quot;Macro Runner&quot;, if you like - a different part of NIHImage. This is done using the &quot;Special&quot; menu. <BR><BR>A macro which is present in a text window can be loaded into the&quot;Macro Runner&quot; using &quot;Special&quot; then &quot;LoadMacros from Window&quot;. Alternatively, you can load macros straightfrom disk by closing any text windows then clicking &quot;Special&quot;;this time there will be an option &quot;Load Macros...&quot; whichlets you load them into the &quot;Macro Runner&quot; from disk.<BR><BR>Macros which have been loaded into the &quot;Macro Runner&quot;appear at the bottom of the &quot;Special&quot; menu as a listof titles. Clicking on the title runs the macro. Remember, thetitle of a macro goes in single speech marks '...' after the &quot;macro&quot;command. There don't seem to be any restrictions on what you cancall a macro, though it's best not to have titles that are toounwieldy.<BR><BR><BR>2.6 Macro programs and macro files<BR><BR>We need to make this distinction clear. A single macro is a &quot;macroprogram&quot;. More than one of these can be entered into a singletext window, then the whole lot saved as a single &quot;macrofile&quot;. The &quot;Macro Runner&quot; uses macro files, notindividual programs - so you can easily load up more than oneprogram, but if you do want to have a group of macro programsall accessible together, they must be saved in the same macrofile. The best way to understand this is to play with the differentmacro files supplied with NIH Image, in the &quot;Macros&quot;directory - open the files as text windows, and check out thevarious macro titles, then try loading them from the window intothe &quot;Macro Runner&quot;, and check out how the &quot;Special&quot;menu appears.<BR><BR><BR>2.7 The 32k limit<BR><BR>No macro file can be larger than 32k. If it is, NIH Image willonly let you load in the first 32k of it. This may sound likea problem, but you can actually fit an awful lot of program into32k. It's unlikely that you'll ever produce a macro file whichis larger than 32k, even with extensive notes and comments.<BR><BR><BR>2.8 Hotkeys<BR><BR>Instead of having to click on the &quot;Special&quot; menu, thenselecting the macro you want, macros can also be programmed toexecute using a defined &quot;Hotkey&quot;. This goes after thetitle, in square brackets []. For example:<BR><BR>macro 'Just Comments [J]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; {This is a comment}<BR>end;<BR><BR>macro 'Beep After Click [B]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; repeat until button;<BR>&nbsp; &nbsp; &nbsp; Beep;<BR>end;<BR><BR>Load in these two macros from a single text window, then checkthe &quot;Special&quot; menu - you'll see the hotkeys after thetitles. Just pressing J or B will run them (not that J actuallydoes anything, mind!).<BR><BR><BR>2.9 Organising the &quot;Special&quot; menu<BR><BR>Macros appear on the &quot;Special&quot; menu list in the orderthey appear in the macro file. If you have a lot of macros inthe same file, it can be useful to divide up the long list oftitles with dividing lines. This is done using this one-line statement:<BR><BR>macro '(-';<BR><BR>This isn't really a macro at all: all it does is insert a linein the &quot;Special&quot; menu list.<BR><BR><BR>2.10 Autoloading a macro file<BR><BR>You can nominate one macro file to be loaded automatically whenNIH Image is loaded, such that the macros it contains are immediatelyavailable to be run. The file must be called &quot;Image Macros&quot;and must be in the same directory as NIH Image (i.e. the applicationwith the microscope icon). This can be useful if you are usingthe same set of macros over and over again.<BR><BR><BR>2.11 Figuring all this out<BR><BR>The best way to practice &quot;macro handling&quot; is to playwith the macros that come supplied with NIH Image, in the &quot;Macros&quot;directory. Practice loading them into the text editor, and intothe &quot;Macro Runner&quot;, and practice running them usinghotkeys. (Note that some require an image file also to be loaded,which they can operate on). This will also give you a good ideaof (1) the different things macros can do, and (2) what the macrolanguage looks like. &quot;Fun and Games&quot; is a good one tobegin with.</FONT></TT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor301893"></A><B><TT><FONT FACE="Courier">3.Variables</FONT></TT></B><TT><FONT FACE="Courier"><BR><BR>3.1 Introduction to variables<BR><BR>Variables allow you to store and manipulate numbers and text strings.You have to understand how to handle variables before you cando anything else, really. Variables are assigned values usingthe &quot;assignment operator&quot;, which is a colon followedby an equals sign (:=). Note that this is different from manyother programming languages, where an &quot;=&quot; on its owndoes the job. This is not the case in Pascal, where the lone &quot;=&quot;has a specific meaning (see later).<BR><BR>So, we assign values to variables like this:<BR><BR>a:=5;<BR><BR>b:=10;<BR><BR>c:=250;<BR><BR>counter:=1000;<BR><BR>There doesn't seem to be any limit on the length of a variablename, though it's best not to let them get too long. Short andinformative is the way to go. <BR><BR><BR>3.2 Types of variables<BR><BR>The NIH Image macro language has four types of variables: integers,real numbers, booleans, and strings. Integers are whole numbers(no decimal places). Real numbers can have decimal places. Booleanvariables are for use in boolean logic, and have only two values,true or false. Strings contain text characters.<BR><BR><BR>3.3 Specifying the type of each variable<BR><BR>Now, it is a peculiarity of Pascal that it is a &quot;strongly-typed&quot;language, which means that before any macro starts doing anything,we need to specify for each variable, which type it is. This isdone in a section of the macro after the &quot;var&quot; statement.So the basic structure of a macro is now:<BR><BR>macro 'Title [T]';<BR>var<BR>&nbsp; &nbsp; &nbsp; {variable types specified here}<BR>begin<BR>&nbsp; &nbsp; &nbsp; {actual macro commands}<BR>end;<BR><BR>So, to take the four example variables above: they are all integers,so we would specify them as follows:<BR><BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>&nbsp; &nbsp; &nbsp; c: integer;<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR><BR>Let's say we also want to use &quot;height&quot; and &quot;width&quot;,which are real numbers, &quot;testflag&quot;, which is a booleanvariable, and &quot;username&quot;, which is a text string. Wewould specify these as follows:<BR><BR>&nbsp; &nbsp; &nbsp; height: real;<BR>&nbsp; &nbsp; &nbsp; width: real;<BR>&nbsp; &nbsp; &nbsp; testflag: boolean;<BR>&nbsp; &nbsp; &nbsp; username: string;<BR><BR><BR>3.4 Shorthand for specifying variable types<BR><BR>Instead of typing<BR><BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>&nbsp; &nbsp; &nbsp; c: integer;<BR><BR>we can get away with<BR><BR>var<BR>&nbsp; &nbsp; &nbsp; a,b,c: integer;<BR><BR>to save space. I generally prefer the longhand version, sinceit is clearer, unless space is getting very short.<BR><BR><BR>3.5 The PutMessage command<BR><BR>Before we can do anything with variables, we need some means ofchecking what is going on, and the effects of our manipulations.The simplest way to get output to the screen in NIH Image is touse the PutMessage command, which brings up a dialogue box onthe screen with our chosen message in it, and an &quot;OK&quot;box to click. For example:<BR><BR>macro 'Say Hello [H]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; PutMessage('Hello.');<BR>end;<BR><BR>Whatever is in the single speech marks '...' appears in the dialoguebox.<BR><BR><BR>3.6 Displaying the values of variables<BR><BR>PutMessage can also output the values of variables, which areseparated from any '...' output by a comma. So:<BR><BR>macro 'Variable Output [V]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=5;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of a is ',a);<BR>end;<BR><BR>If a variable is given a type, but not assigned a value, it justtakes the value zero. To demonstrate this:<BR><BR>macro 'Zero Value Check [N]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of a is:',a);<BR>end;<BR><BR>But always remember that you can't use a variable in the mainprogram without having specified what type it is in the &quot;var&quot;section.<BR><BR><BR>3.7 Mathematical operations<BR><BR>Integer and real variables can be added, subtracted, multipliedand divided by using the +, -, * and / symbols respectively. Thefollowing examples all use integers, for simplicity.<BR><BR>macro 'Add Values [A]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=10;<BR>&nbsp; &nbsp; &nbsp; b:=a+4;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of b is:',b);<BR>end;<BR><BR>macro 'Subtract Values [S]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=10;<BR>&nbsp; &nbsp; &nbsp; b:=a-4;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of b is:',b);<BR>end;<BR><BR>macro 'Multiply Values [M]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=10;<BR>&nbsp; &nbsp; &nbsp; b:=a*6;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of b is:',b);<BR>end;<BR><BR>macro 'Divide Values [D]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=10;<BR>&nbsp; &nbsp; &nbsp; b:=a/2;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of b is:',b);<BR>end;<BR><BR><BR>3.8 Div and mod commands<BR><BR>The div and mod commands are used during division of integers.Div ignores the remainder of any division, such that &quot;9 div4&quot; equals two. Mod only gives the remainder, such that &quot;9mod 4&quot; equals one. So together, these two commands give usthe whole picture, i.e. 9 divided by 4 is two remainder one. Noteagain that they can only work with integers.<BR><BR>macro 'Div Test [D]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>&nbsp; &nbsp; &nbsp; c: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=9;<BR>&nbsp; &nbsp; &nbsp; b:=4;<BR>&nbsp; &nbsp; &nbsp; c:=a div b;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The answer is: ',c);<BR>end;<BR><BR>macro 'Mod Test [M]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>&nbsp; &nbsp; &nbsp; c: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=9;<BR>&nbsp; &nbsp; &nbsp; b:=4;<BR>&nbsp; &nbsp; &nbsp; c:=a mod b;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The answer is: ',c);<BR>end;<BR><BR><BR>3.9 Real numbers and integers<BR><BR>Integers must be whole numbers with no decimal places. This meansthat 3, 4, and 5 are all integers, but 3.0, 4.00 and 5.0000 arenot - they are reals. Now, there is no reason why you can't adda real to an integer, or divide an integer by a real, etc, butthe result will always be another real. Both integers and realnumbers can be negative. There are limits on how big numbers canget in NIH Image (although they are vast: billions of billions).Similarly, real numbers have a limited number of decimal placeswhich can be accurately stored.<BR><BR><BR>3.10 Booleans and strings<BR><BR>Boolean variables can only have two values: true or false. Youcan literally type &quot;true&quot; or &quot;false&quot; intothe macro:<BR><BR>macro 'Boolean Assign';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=true;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of a is:',a);<BR>end;<BR><BR>However, the value is stored as a number: 1 for true and 0 forfalse. So the macro above prints 1 as the value of a (or 0 if&quot;a:=false&quot; is used). The values 1 and 0 can be directlyassigned instead - so although a boolean variable must be eitherone value or another, there are two ways of expressing this dichotomy.<BR><BR>String variables contain text (or numbers, spaces, and other characters)and can be up to 255 characters long. They are inputted betweensingle speech marks '...'.<BR><BR>macro 'String Assign';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: string;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:='NIH Image';<BR>&nbsp; &nbsp; &nbsp; PutMessage('The string is: ',a);<BR>end;<BR><BR><BR>3.11 Take care with different types of variable<BR><BR>Now, in proper Pascal, you can't assign an inappropriate valueto any type of variable without getting an error message. NIHImage is not as strict: you can assign 3.45 to an integer, or2 to a boolean, without complaint - until you try to do somethingwith them, in which case you may find the integer has been roundedoff, and the boolean &quot;nonsense value&quot; will cause a crash.It is best to &quot;police yourself&quot;, and make sure thatall your variables are specified as certain types in the var sectionof the macro, and that they are only ever assigned appropriatevalues. This'll make your code much easier to follow, and lesslikely to contain bugs.<BR><BR>macro 'Well Assigned';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: real;<BR>&nbsp; &nbsp; &nbsp; c: boolean;<BR>&nbsp; &nbsp; &nbsp; d: string;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=15;<BR>&nbsp; &nbsp; &nbsp; b:=3.145;<BR>&nbsp; &nbsp; &nbsp; c:=true;<BR>&nbsp; &nbsp; &nbsp; d:='London';<BR>end;<BR><BR><BR>3.12 Future work with variables<BR><BR>We'll look at reals, integers, and (especially) booleans in muchmore detail later on (strings aren't so important in image analysis).Don't worry if you have unanswered questions at this stage. Forextra practice, load up some of the macros that come with NIHImage into the text editor, decipher the list of variables inthe &quot;var&quot; sections, then try and track the variablesthrough each macro and see what happens to them. &quot;LUT Macros&quot;has plenty of variables, for example.<BR></FONT></TT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor302455"></A><B><TT><FONT FACE="Courier">4.Decimals, powers, and text output</FONT></TT></B><TT><FONT FACE="Courier"><BR><BR>4.1 Decimal places<BR><BR>This is a minor topic, but quite awkward to understand so it'sworth covering in detail. Obviously, here we're only dealing withreal variables (though as I've said before, NIH Image doesn'tactually complain if you try and add decimal places to integersor booleans!). <BR><BR>To begin, any real of the format x.0, x.00, x.000, etc, is justprinted as x. To demonstrate:<BR><BR>macro 'Real Variable [R]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: real;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=7.00000;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The variable a is:',a);<BR>end;<BR><BR>But, as soon as the decimal places are anything other than zeroes,the display switches to a standard &quot;four decimal places mode&quot;.So, 1.2345 is just displayed as 1.2345. 1.2 is &quot;padded&quot;with zeroes, so it is displayed as 1.2000. Any real with morethan four decimal places is rounded off, so 1.234567 is displayedas 1.2346. You can check these by modifying the macro above. Notethat this rounding doesn't affect the actual value of the variable,just the value that is displayed. So, it would be useful to knowhow to expand upon this standard &quot;four decimal places mode&quot;.<BR><BR><BR>4.2 How to change them<BR><BR>This is quite involved, so bear with me. The first step is todecide how many decimal places you want to display. Let's sayyou have a value x of 1.2345678, which has seven decimal placesoverall. To print it with the standard four decimal places, youwould use<BR><BR>PutMessage(x);<BR><BR>To get all seven decimal places, you would use:<BR><BR>PutMessage(x:1:7);<BR><BR>And in general, to get 'd' decimal places, you would use:<BR><BR>PutMessage(x:1:d);<BR><BR>The obvious question is now: what does the 1 control in this format?For a variable x, in the format<BR><BR>PutMessage(x:f:d);<BR><BR>d refers to the number of decimal places and f refers to the fieldwidth. This is the number of character spaces in which the numberis printed. It works like this: &quot;1&quot; requires 1 space;&quot;2.4&quot; requires 3 spaces (one for the decimal point);&quot;10.03&quot; 5 spaces, &quot;1029.46573&quot; 10 spaces,and so on. This is simple enough, but how come the examples aboveall have a field width of one? The answer is that the decimalplaces value, d, overrides the field width value f. If the valueof d that we specify requires more decimal places than the fieldwidth we specify, then NIH Image just uses the minimum field widthnecessary to print all those decimal places. So, the simple answeris, forget about field widths and always use<BR><BR>PutMessage(x:1:d);<BR><BR>so that you can control the number of decimal places. For theinterested, the reason why field width is important is becausePascal uses right-aligned numbers (so that they print correctlyin columns). So, if you want to put a space in front of variablex, with the value &quot;1.23&quot;, for example: you need 4 spacesfor the number (remember, the decimal point needs one too), andanother for the space, so you need a field width of 5. So:<BR><BR>PutMessage('The number is:',x:5:2);<BR><BR>will print a space between the colon and the number. But you canjust as easily put the space between the speech marks and notworry about having to calculate a field width, which is much simpler:<BR><BR>PutMessage('The number is: ',x:1:2);<BR><BR>will have the same effect.<BR><BR><BR>4.3 Mangling of decimal places<BR><BR>I have noticed that NIH Image isn't very good at displaying lotsof decimal places. Above about 7 or 8 decimal places, the outputtends to get a bit mangled, with extra random numbers appearing.For example, here's an attempt to display 15 decimal places. Tryit and see whether it works.<BR><BR>macro 'Many Decimals [M]';<BR>var<BR>&nbsp; &nbsp; &nbsp; x: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; x:=1.23456789012345;<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Text Output');<BR>&nbsp; &nbsp; &nbsp; WriteLn(x:1:15);<BR>end;<BR><BR><BR>4.4 Why there isn't a power operation<BR><BR>Switching topics completely: now let's concentrate on calculatingpowers (using only integers, for simplicity). We immediately hitan obstacle: there isn't a command in the macro language to calculatethem! This is a result of the minimalist philosophy behind Pascal.Powers can be calculated using two simpler commands, so there'sno need for a specific power command.<BR><BR>First, let me introduce two new functions. These are ln(x), whichgenerates the natural logarithm of x, and exp(x), which is e tothe power x. We can assign the outputs of these functions to newvariables easily, like this:<BR><BR>x:=ln(y);<BR><BR>a:=exp(b);<BR><BR>Thinking back to A-level maths, you will recall that a to thepower b is equal to e to the power of (b times the natural logof a). <BR><BR><BR>4.5 The power-calculating macro<BR><BR>So, we have to combine these two functions to get our power-calculatingmacro. Here it is:<BR><BR>macro 'Power [P]';<BR>&nbsp; &nbsp; &nbsp; {Purpose: calculate a to the power b}<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>&nbsp; &nbsp; &nbsp; result: real;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=3;<BR>&nbsp; &nbsp; &nbsp; b:=6;<BR>&nbsp; &nbsp; &nbsp; result:=exp(b*ln(a));<BR>&nbsp; &nbsp; &nbsp; PutMessage('The result is:',result:1:0);<BR>end;<BR><BR>Note how we use brackets on the crucial line of calculation, toavoid ambiguity in calculation. This is a good practice to followgenerally. NIH Image is clever enough to do multiplication beforeaddition, and so on, but even so: use brackets wherever possibleto reduce ambiguity and make code clearer. Note also the use ofcomments to clarify that we are calculating a to the power b andnot the other way round. Why do we need &quot;result:1:0&quot;?Surely the answer should be an integer? Well, because we are usingthe exponential-and-logarithm method, the intermediate valuesin the calculation have to be real, so the answer must be real.So if we don't have the result:1:0, we get 729.0000 printed. (Notethat we can still specify &quot;answer&quot; as an integer ifwe like - NIH Image doesn't complain, but it will still print729.0000 unless we specify no decimal places!).<BR><BR>This macro only deals with positive integers. Negative numberswill cause a crash, since you can't calculate the natural logarithmof a negative number. It is OK to set b to zero, but not a: tryingto calculate ln(0) gives an error also.<BR><BR><BR>4.6 Using GetNumber<BR><BR>In order to use different values in the calculation above, wehave to edit the macro code itself. By using the GetNumber command,we can enable the user to type in values for a and b when themacro is run.<BR><BR>macro 'Power With Input [I]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>&nbsp; &nbsp; &nbsp; b: integer;<BR>&nbsp; &nbsp; &nbsp; result: real;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=GetNumber('Enter The Number (An Integer):',5,0);<BR>&nbsp; &nbsp; &nbsp; b:=GetNumber('Enter The Power (An Integer):',2,0);<BR>&nbsp; &nbsp; &nbsp; result:=exp(b*ln(a));<BR>&nbsp; &nbsp; &nbsp; PutMessage('The Result Is: ',result:1:0);<BR>end;<BR><BR>See how GetNumber works? There are three sections in the brackets,separated by commas. The first, inside the speech marks '...',is the text which appears in the GetNumber dialogue box. The secondis a suggested value, which comes ready-selected in the inputbox. The third number is the number of decimal places for thesuggested value - zero, in our case, since we our default values(which are selected if the user just clicks OK) are 5 and 2, resultingin an answer of 25. In a sense, GetNumber is a function just likeln(x) - both return single numerical values which are assignedto other variables.<BR><BR><BR>4.7 Back to text output<BR><BR>Switching topics once more, we return to text output. So far,we've only covered PutMessage as a means of text output. A usefulcomplement to this is ShowMessage, which prints text in the Infowindow.<BR><BR>macro 'Info Window Hello';<BR>begin<BR>&nbsp; &nbsp; &nbsp; ShowMessage('Hello.');<BR>end;<BR><BR>We can alter any of the macros we've written so far with textoutput, to have that output in the Info window instead of in adialogue box which needs its OK button clicking. The commandsare equivalent - ShowMessage can incorporate variables as well.<BR><BR>The rule is that you can only print one message at a time in theInfo window. Any new message will overwrite the previous one.To see this, run the following macro:<BR><BR>macro 'Waiting [W]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; ShowMessage('Start');<BR>&nbsp; &nbsp; &nbsp; wait(5);<BR>&nbsp; &nbsp; &nbsp; ShowMessage('Waiting for 5 seconds');<BR>&nbsp; &nbsp; &nbsp; wait(5);<BR>&nbsp; &nbsp; &nbsp; ShowMessage('Waiting for 10 seconds');<BR>end;<BR><BR>The command wait(x) just makes the computer wait for x seconds- we'll use this again later on. So, after 5 and 10 seconds, theInfo window tells you how long the computer has been waiting.<BR><BR><BR>4.8 Multi-line statements in the Info window<BR><BR>To get more text into the Info window, we can incorporate &quot;carriagereturns&quot; into our ShowMessage commands - equivalent to pressingenter. The backslash character \ represents a carriage return.It must go at the front of each new line, and is not printed eventhough it goes within the speech marks. For example:<BR><BR>macro 'Two Lines [T]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; ShowMessage('First line','\Second Line');<BR>end;<BR><BR>See how &quot;Second Line&quot; appears on a new line withoutthe &quot;\&quot;? We can actually use &quot;\&quot; on its ownto create a blank line:<BR><BR>macro 'Miss A Line [M]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; ShowMessage('First line','\','\Second line');<BR>end;<BR><BR>But the one thing we can't do is split these statements into morethan one ShowMessage command. This is the restricting rule - eachnew ShowMessage command wipes out everything that was before itin the Info window. So to print anything of substance in the Infowindow, you need a really long ShowMessage statement - it isn'tmuch use, really. To get proper control over text output, we needto look at generating text windows.<BR><BR><BR>4.9 Generating a text window for text output<BR><BR>Remember when we first created a macro? The first thing you dois to create a new text window off the &quot;File&quot; menu.We can do this from within a macro, using the NewTextWindow command(obviously enough!):<BR><BR>NewTextWindow('Window Title');<BR><BR>is the syntax. This creates a text window exactly the same asthe ones you type macros into. Once the macro is finished, andthe text window remains, it can be saved as an NIH Image &quot;TEXT&quot;file, reloaded, edited, and so on.<BR><BR><BR>4.10 Writing in a text window<BR><BR>This section is based on the premise that we only have one windowopen when the macro is running - the text window we have generatedusing NewTextWindow. If we have more than one text window, oran image window as well, then things get more complicated. Butwe'll deal with that later.<BR><BR>We write in text windows using the Write and WriteLn commands.As long as only one text window has been launched, there is noconfusion for the computer over where to write. Basically, &quot;Write('....');&quot;just prints what is in the '....' - without a carriage return.&quot;WriteLn('....');&quot; prints the string and does includea carriage return, i.e. whatever is next printed starts on a newline. So &quot;WriteLn;&quot; on its own is the equivalent ofpressing enter.<BR><BR>The following macro prints &quot;First Statement&quot; using &quot;Write&quot;,then uses &quot;WriteLn&quot; to press enter, then uses anotherWriteLn command to miss a line, then prints-&quot;Second Statement&quot;-and-presses-enterall-in-one by using WriteLn with a statement. It all becomes clearonce you have used them a few times.<BR><BR>macro 'New Text Window';<BR>begin<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Text Output');<BR>&nbsp; &nbsp; &nbsp; Write('First Statement');<BR>&nbsp; &nbsp; &nbsp; WriteLn;<BR>&nbsp; &nbsp; &nbsp; WriteLn;<BR>&nbsp; &nbsp; &nbsp; WriteLn('Second Statement');<BR>end;<BR><BR>&quot;Macro Text Output&quot; is the name of the new text window;if it is clicked closed, after the macro has finished, then theprogram will prompt a save of the TEXT file with the same name.<BR><BR>In general, it's much easier to use text windows for text output,except when a clickable dialogue box is needed to get the user'sattention. WriteLn is almost always used as well, rather thanWrite, because of its automatic carriage return. From now on,we'll use test windows for text output, except in our minor &quot;testmacros&quot;.<BR><BR>Note that we can also print string variables using Write and WriteLn:<BR><BR>macro 'Print Name';<BR>var<BR>&nbsp; &nbsp; &nbsp; name: string<BR>begin<BR>&nbsp; &nbsp; &nbsp; name:='Michael';<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Text Output');<BR>&nbsp; &nbsp; &nbsp; WriteLn(name);<BR>end;<BR><BR><BR>4.11 The 32k limit (again)<BR><BR>As we know, macro files (which are written in text windows) can'tbe larger than 32k. In fact, this restriction applies to all NIHImage text windows - so that the text output from a macro intoa new text window can't be larger than 32k, either. This meansthat you can't print out large amounts of data into a text window.But there are other ways of dealing with large amounts of resultsdata, of which more later.</FONT></TT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><FONT FACE="Courier"><BR><BR></FONT><A NAME="anchor303060"></A><B><TT><FONT FACE="Courier">5.Functions and procedures</FONT></TT></B><FONT FACE="Courier"><BR><BR>5.1 Global variables<BR><BR>So far, every time we write a macro that uses variables, we'vehad to include a &quot;var&quot; section at the start of thatmacro, where we assign a type to each variable. The variablesin separate macros are totally separate - even if they have thesame names. Each time we run a new macro, the computer &quot;forgets&quot;about any variables that might have been used in previous macros.<BR><BR>Because we can have more than one macro program in a macro file- and almost always will do, once things get more complicated- then it is very useful to have &quot;global variables&quot;as well as standard &quot;macro variables&quot;. Global variablesare accessible to all the macros in a file. They have types assignedin a &quot;var&quot; section at the very top of the file, beforeany of the macros. Here's a simple example.<BR><BR>var<BR>&nbsp; &nbsp; &nbsp; answer: real;<BR><BR>macro 'Add Numbers [A]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: real;<BR>&nbsp; &nbsp; &nbsp; b: real;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=GetNumber('Enter the first number',2,2);<BR>&nbsp; &nbsp; &nbsp; b:=GetNumber('Enter the second number',3,2);<BR>&nbsp; &nbsp; &nbsp; answer:=a+b;<BR>end;<BR><BR>macro 'Show Answer [S]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; ShowMessage('The added result is: ',answer:1:2);<BR>end;<BR><BR>The variable &quot;answer&quot; is global - we assign it a valuein &quot;Add Numbers&quot;, then display it in &quot;Show Answer&quot;.Simple enough. In fact, this is the only way to pass a value betweentwo macros like this - if we &quot;initialised&quot; the variable&quot;answer&quot; in both macros, the second one wouldn't workbecause the value wouldn't be passed across. Note that all weare doing at the top is specifying the TYPE of the global variable;we aren't actually assigning it a value until the macros themselvesare run.<BR><BR><BR>5.2 A simple macro file with a global variable<BR><BR>Here's a longer example, though still very simple:<BR><BR>var<BR>&nbsp; &nbsp; &nbsp; number: integer;<BR><BR>macro 'Input Number [I]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; number:=GetNumber('Enter an integer',7,0);<BR>end<BR><BR>macro '(-';<BR><BR>macro 'Multiply By 2 [A]';<BR>var<BR>&nbsp; &nbsp; &nbsp; answer2: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; answer2:=number*2;<BR>&nbsp; &nbsp; &nbsp; ShowMessage('Integer*2 = ',answer2:1:0);<BR>end;<BR><BR>macro 'Multiply By 4 [B]';<BR>var<BR>&nbsp; &nbsp; &nbsp; answer4: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; answer4:=number*4;<BR>&nbsp; &nbsp; &nbsp; ShowMessage('Integer*4 = ',answer4:1:0);<BR>end;<BR><BR>macro 'Multiply By 8 [C]';<BR>var<BR>&nbsp; &nbsp; &nbsp; answer8: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; answer8:=number*8;<BR>&nbsp; &nbsp; &nbsp; ShowMessage('Integer*8 = ',answer8:1:0);<BR>end;<BR><BR>See how the &quot;macro file&quot; concept is starting to work?A set of related macros, that fill up the &quot;Special&quot;menu with different functions, organised by dividing lines andinstantly accessible by hotkeys.<BR><BR><BR>5.3 Introduction to functions<BR><BR>We've already met two functions in Pascal: exp(x) and ln(x). Whatexactly is a function? Well, the rule is that a function can onlyever produce a single value. Whatever you put in, you only everget a single number out. So the basic syntax for a function justuses the assignment operator ':=' ... like, a:=exp(x) or b:=ln(y).In general, we use Result:=FunctionName(Input).<BR><BR>Now, exp(x) and ln(x) are &quot;given&quot; functions - the codethat actually does the calculation is already in NIH Image, sowe don't have to worry about it. But what if want to define ourown functions? We need three things: the name of the function,the input variable name(s) and type(s), and the output variabletype. Remember that we can have lots of input variables to a functionif we like, but only ever one output variable, since a functioncan only ever return a single value. Don't we need to know thename of the output variable? No, because this is denoted by thefunction name - they are the same thing, if you see what I mean.<BR><BR><BR>5.4 Function variables<BR><BR>Let's say the function is going to be called &quot;square&quot;,and will calculate the square of an integer. So, we have one outputvariable (an integer). We say that the function &quot;returns&quot;an integer. We define it like this:<BR><BR>function square: integer;<BR><BR>The syntax is very similar to assigning a variable type. But wealso have an input variable (another integer - let's call it &quot;input&quot;),so we need to include this in the definition:<BR><BR>function square(input: integer;): integer;<BR><BR>In general, it looks like:<BR><BR>function title(input variable names and types;): output variabletype;<BR><BR>If we have more than one input variable, we could use somethinglike:<BR><BR>function FunctionName(a: integer; b: integer; c: integer;): integer;<BR><BR>though remember we can abbreviate this to:<BR><BR>function FunctionName(a,b,c: integer;): integer;<BR><BR><BR>5.5 The square function<BR><BR>Getting back to the square function, here is the very simple code:<BR><BR>function square(input: integer;): integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; square:=input*input;<BR>end;<BR><BR>There's no &quot;var&quot; section, since we already know aboutthe variable types from the first line. All we have to do is definehow we get from the input variable to the function output, usingthe assignment operator :=.<BR><BR>Now we can write a quick macro to use this function:<BR><BR>macro 'Get Square [S]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=GetNumber('Enter the integer to be squared:',5,0);<BR>&nbsp; &nbsp; &nbsp; a:=square(a);<BR>&nbsp; &nbsp; &nbsp; PutMessage('The result is ',a:1:0);<BR>end;<BR><BR>Note that this macro goes after the function it uses. Functionsand procedures must always be placed BEFORE the macros that usethem in the macro file. So the whole macro file is:<BR><BR>function square(input: integer;): integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; square:=input*input;<BR>end;<BR><BR>macro 'Get Square [S]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=GetNumber('Enter the integer to be squared:',5,0);<BR>&nbsp; &nbsp; &nbsp; a:=square(a);<BR>&nbsp; &nbsp; &nbsp; PutMessage('The result is ',a:1:0);<BR>end;<BR><BR><BR>5.6 More on functions<BR><BR>Actually, the &quot;square&quot; example is a bit pointless, sincethere is a function that calculates squares in Pascal already- sqr(x)! (It provided a good, easy example though). But as Ihave said, it's essential to find out whether you really needbother to program something before you start - if there's a simplerway, then use it. <BR><BR>Some other basic functions for NIH Image macros are sqrt(x) whichreturns the square root, abs(x) which returns the absolute value,i.e. knocks off any decimal places, round(x) which rounds to thenearest integer, random - which returns a random number between0 and 1 (note: it doesn't need an input value) and several others.Browse the list of NIH Image Macro Commands to find more.<BR><BR>For example, sin(x) and cos(x) are self-explanatory - though thereis no tan(x). Why not? Same reason as there is no power command:tan(x) equals sin(x) over cos(x). So here's an opportunity toprogram a genuinely useful function.<BR><BR><BR>5.7 The tan function<BR><BR>We have one input value (an angle, in radians) and one outputvalue (the tangent). Both obviously need to be reals. Here's thecode, without further ado:<BR><BR>function tan(input: real;): real;<BR>begin<BR>&nbsp; &nbsp; &nbsp; tan:=sin(input)/cos(input);<BR>end;<BR><BR>macro 'Find Tangent [F]';<BR>var<BR>&nbsp; &nbsp; &nbsp; angle: real;<BR>&nbsp; &nbsp; &nbsp; result: real;<BR>begin<BR>&nbsp; &nbsp; &nbsp; angle:=GetNumber('Enter the angle (in radians)',3.142,3);<BR>&nbsp; &nbsp; &nbsp; result:=tan(angle);<BR>&nbsp; &nbsp; &nbsp; PutMessage('The tangent is ',result);<BR>end;<BR><BR>Note that the result is printed with the default four decimalplaces. <BR><BR><BR>5.8 Extending the macro language<BR><BR>Once we've placed the tan function in our macro file, we can useit in all subsequent macro programs in that file. In effect, we'veadded a new command to the language. Computer language is verypowerful in this way - we can build small modules that do simplethings, then call upon them from more complex programs, then usethese programs as building blocks for even greater things. Oneway to write very powerful macros is to split them up into simple,smaller units - a modular approach to programming. Functions andprocedures are useful for this.<BR><BR><BR>5.9 Introduction to procedures<BR><BR>Functions can only return a single value. Procedures can do virtuallyanything. They are much more powerful than functions. You canabstract a section of code from a program, put it in a procedure,and then just call the procedure whenever you want that code tobe run. This allows for much more efficient programming. Onlya very simple example of a procedure will be given here: here'sthe code. See if you can figure out how it fits together.<BR><BR>procedure calculation;<BR>begin<BR>&nbsp; &nbsp; &nbsp; number:=number+increment;<BR>end;<BR><BR>macro 'Add Two [A]'; <BR>var<BR>&nbsp; &nbsp; &nbsp; number: integer;<BR>&nbsp; &nbsp; &nbsp; increment: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; increment:=2;<BR>&nbsp; &nbsp; &nbsp; number:=GetNumber('Enter an integer',5,0);<BR>&nbsp; &nbsp; &nbsp; calculation;<BR>&nbsp; &nbsp; &nbsp; ShowMessage('The result is ',number:1:0);<BR>end;<BR><BR>This is an &quot;unnecessary&quot; procedure, in that we couldhave left the line<BR><BR>number:=number+increment;<BR><BR>within the program itself, and done without the procedure. Butthings can obviously get more complicated: we'll encounter proceduresagain in a &quot;proper&quot; macro in chapter 10. Note that aswith functions, procedures must come before the macros that callthem in the macro file.<BR><BR>In general, if a macro program starts to get too long (say, greaterthan a page full of code), then consider breaking it up into procedures- it'll be much easier to follow and debug. For further practice,check out the example macros supplied with NIH Image, and findout how they use global variables, functions, and procedures.An excellent example is the &quot;Demo Macro&quot;, which is almostentirely organised into procedures.<BR></FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor303746"></A><B><TT><FONT FACE="Courier">6.For loops</FONT></TT></B><FONT FACE="Courier"><BR><BR>6.1 Introduction<BR><BR>For loops let you repeat an operation a certain number of times.The &quot;operation&quot; can be a load of different things together,if you like. But the golden rule is that you have to know howmany times you're going to repeat them, before you start. A forloop has to be &quot;fixed&quot; in this way.<BR><BR><BR>6.2 Single statement for loops<BR><BR>The basic for loop structure looks like this:<BR><BR>for counter:=1 to 10 do<BR>&nbsp; &nbsp; &nbsp; command;<BR><BR>We have the variable &quot;counter&quot; (or you can call it whatyou like), which must be an integer. The command is then repeated10 times. We could run counter from 1 to 5, to repeat the command5 times, or indeed from 5 to 10, or whichever values we like.But it can only go up by 1 with each cycle. It's a variable justlike any other - so it has to have its integer type specifiedin the &quot;var&quot; section.<BR><BR>Important: note that there is only one semicolon in the abovestatement - at the end. There isn't one after the &quot;do&quot;.<BR><BR>As an example, here's a macro which prints the numbers from 1to 20 in a text window, using a for loop.<BR><BR>macro 'For Loop [F]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; for counter:=1 to 20 do<BR>&nbsp; &nbsp; &nbsp; WriteLn(counter);<BR>end;<BR><BR>See how it works? The WriteLn command after the for statementis executed, then the counter variable is incremented, then thecommand is repeated, and so on, until the counter reaches 20,when the command is executed for the last time.<BR><BR><BR>6.3 Multiple statement for loops<BR><BR>There's an obvious limitation here - we can only put one commandafter the for statement. How about multiple commands? Now, wehave to introduce a &quot;begin ... end&quot; structure into thefor loop. The basic structure is modified to:<BR><BR>for counter:=1 to 10 do begin<BR>&nbsp; &nbsp; &nbsp; command 1;<BR>&nbsp; &nbsp; &nbsp; command 2;<BR>&nbsp; &nbsp; &nbsp; command 3;<BR>end;<BR><BR>See how all the commands go between the begin and the end? Nowwe can have multiple commands, which need to be terminated bysemicolons. But ignore the commands for a minute, and just lookat the for statement structure:<BR><BR>for counter:=1 to 10 do begin ... end;<BR><BR>See how there is only one semicolon again? The for loop is a singlecommand, in a sense, so it is terminated by a single semicolonat the end. Each action within the for loop is a separate command,and also needs to be terminated. Hopefully you can understandwhere all the semicolons belong!<BR><BR>Here's an example, extended from the example above:<BR><BR>macro 'Longer For Loop [L]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; for counter:=1 to 20 do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn(counter);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait(1);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('And the loopstarts again...');<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR><BR>6.4 Indenting - a note<BR><BR>See how the above example has two &quot;ends&quot; at the end?Each of these &quot;ends&quot; belongs to a &quot;begin&quot;.Go straight up from the last end, and you'll hit the begin thatstarts the macro. Go straight up from the penultimate end, andyou'll hit the for statement and its begin. This indenting ofthe code is starting to become useful to help us follow the structureof the code. I always indent in 5 spaces for each &quot;chunk&quot;of code ... after the first &quot;begin&quot;, then within anyfor loop, and also for other types of commands which we'll meetlater. The key is not to follow my example exactly, but to beconsistent in how you indent, which makes your code much easierfor you (and others) to understand.<BR><BR><BR>6.5 For loops with procedures<BR><BR>You may already have thought of a cunning way to expand the simplefor loop described in section 6.2. Here it is:<BR><BR>procedure loopstuff;<BR>begin <BR>&nbsp; &nbsp; &nbsp; command 1;<BR>&nbsp; &nbsp; &nbsp; command 2;<BR>&nbsp; &nbsp; &nbsp; command 3;<BR>end;<BR><BR>for x:=a to b do<BR>&nbsp; &nbsp; &nbsp; loopstuff;<BR><BR>Take the multiple commands, put them in a procedure, then runthe procedure as a single command from within the macro for loop.Cunning. In general, I prefer to use the &quot;begin ... end&quot;structure with all for loops, for clarity. But even so, it canbe useful to &quot;farm out&quot; long lists of instructions toprocedures in this way, to keep the main body of code manageableif you want to do a huge list of different things within a singlefor loop.<BR><BR><BR>6.6 Honest for loops<BR><BR>For loops have to be &quot;honest&quot;. As I said above, youcan only go up in integers, one at a time, and you can't modifythe counter variable from within the for loop. This is a goldenrule of programming. In effect, if you say you're going to countfrom 1 to 10, then you have to ... you can't then decide to stopat 8. For loops have to be honest. Never try and modify the countervariable from within the for loop: doing this makes the initialfor statement a &quot;lie&quot;, which makes the code very trickyto follow. <BR><BR>To go up by a different increment each time, use another variableand calculate its value from the counter. Here's an example, whichcounts from 2 to 40 in steps of 2:<BR><BR>macro 'Stepped For Loop [S]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>&nbsp; &nbsp; &nbsp; stepvalue: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; for counter:=1 to 20 do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stepvalue:=counter*2;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn(stepvalue);<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR><BR>6.7 Nesting of for loops<BR><BR>For loops can be &quot;nested&quot; - one can run within another.This lets you cover a &quot;two-dimensional&quot; concept, e.g.all the coordinates of an image. But as above, you can only incrementone at a time. Here's an example - see if you can predict whatit does:<BR><BR>macro 'Nested For Loop [N]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter1: integer;<BR>&nbsp; &nbsp; &nbsp; counter2: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; for counter1:=1 to 60 do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn(counter1);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for counter2:=1 to 20do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WriteLn(counter2);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>We need two counter variables. For each increment of counter1between 1 and 60, counter2 is run between 1 and 20. So the abovemacro prints out the numbers between 1 and 20 sixty times! Hmmm,useful... but seriously, as I said above, nested for loops areuseful when dealing with images, among other things. Note howthe text window scrolls as it fills up - and how you can editits contents when the macro is finished.<BR><BR>Note also the three &quot;ends&quot; at the end - things are gettingcomplicated now, and careful indenting is essential. Otherwisewe are never sure which end belongs to which begin! To make thingsclearer still, we could add blank lines to the above macro (whichare ignored by the computer) and some comments inside curly brackets{}. Clear, well-organised code is the way to go.<BR><BR><BR>6.8 Counter variables<BR><BR>The counter is just an integer variable: nothing special. So there'sno reason why we can't use any of these:<BR><BR>for x:=1 to limit do<BR><BR>for x:=(a+b) to (c-d) do<BR><BR>for x:=(a+(b*c)) to (abs(exp(q))) do<BR><BR>and so on. Note the use of brackets.<BR><BR><BR>6.9 Breaking free<BR><BR>We've been fretting all this time about keeping our for loopshonest, but what happens when you've just started running a forloop up to 10,000 and realise something is wrong? How do you escape?Here we cover how to break free from a macro once it is running.We can build an &quot;escape hatch&quot; into the code itself,but we need to cover more ground to do this. For now, here areinstructions on how to halt a macro from the outside.<BR><BR>Macros don't multi-task - so if a macro is running, the computeris frozen. To escape from a macro hold down control, the applekey, and the full stop/period (.). This'll stop it running. Notethat the computer won't notice that you are pressing this &quot;escapecombination&quot; until it has finished its immediate task - whatthis means is that in some more complex macros, you might haveto hold down the escape combination for a few seconds. Don't worrythough, it always works, unless the Mac itself has crashed (whichnever happens, right?).<BR><BR><BR>6.10 On semicolons<BR><BR>For a final word, I want briefly to discuss the semicolon symbol; in Pascal. It has a fairly confusing role as a statement separator/terminator,in that it doesn't go after everything, and indeed can cause majorproblems if it is put after every line (e.g. after a for loop).Bear in mind that carriage returns (&quot;new lines&quot;) areignored in Pascal - hence, the need for a terminator symbol. Asemicolon on its own forms an &quot;empty statement&quot; - itis accepted by the computer, but nothing actually happens. Sothis macro is legal, and does nothing:<BR><BR>macro 'Empty Statements [E]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; ;<BR>&nbsp; &nbsp; &nbsp; ;<BR>&nbsp; &nbsp; &nbsp; ;<BR>&nbsp; &nbsp; &nbsp; ;<BR>end;<BR><BR>I have read that you never need a semicolon immediately beforean end statement (i.e. on the end of the preceding line - Pascaltreats carriage returns as spaces remember, basically ignoringthem). This seems to be true - but I find it more logical to putthem in anyway. I'm not sure that there's a general rule aboutwhat semicolons actually do. You just have to learn where to putthem. Develop your own style, that works, and be consistent.</FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><FONT FACE="Courier"><BR><BR></FONT><A NAME="anchor304297"></A><B><TT><FONT FACE="Courier">7.If statements</FONT></TT></B><FONT FACE="Courier"><BR><BR>7.1 Introduction to if statements<BR><BR>If statements deal with either-or situations - they choose betweentwo alternatives (or just &quot;alternatives&quot;, in the strictdefinition of the word). For choosing amongst more than two things,we use a &quot;case&quot; statement in Pascal - not availablein NIH Image, so we have to construct an equivalent from multipleif statements - but let's not worry about this for now. The either-ornature of if statements means that we use BOOLEAN variables todecide what to do. Recall that these can only take the values1 or 0 (or, equivalently, true or false). Before we consider ifstatements further, we need to look at boolean variables in moredetail.<BR><BR><BR>7.2 Introduction to boolean variables<BR><BR>Boolean variables are assigned values using the assignment operator&quot;:=&quot;. For example, &quot;x:=1&quot; and &quot;y:=0&quot;(or &quot;x:=true&quot; and &quot;y:=false&quot; - think of thetwo pairs as totally interchangeable, which, to the computer,they are). We can also assign boolean values in an indirect way:this is a little harder to understand. For example, we can say:<BR><BR>x:=1;<BR>y:=x;<BR><BR>which makes both x and y equal to 1. But this remains simple onlyas long as all the variables are boolean. What if we want to say&quot;if x (an integer) is greater than 5, then y (a boolean)is true&quot;? Read carefully now. This looks like an if statementin the making, i.e. we should use the if command. BUT there isanother way of doing it - more compact but less intuitive. Eitheris perfectly acceptable - all we are looking at here is two waysof getting to the same place. We will cover the short, non-intuitiveway first.<BR><BR><BR>7.3 Boolean expressions<BR><BR>Consider these six &quot;relational operators&quot;. Each resultsin a boolean result, i.e. either true or false, no &quot;middleground&quot;. They are given in Pascal symbols rather than inproper maths symbols, e.g. for &quot;is not equal to&quot;, mathematicsuses an equals sign with a line through it, a symbol which isn'tavailable on a computer keyboard. <BR><BR>= equal to<BR>&lt; less than<BR>&gt; greater than</FONT></P><P><FONT FACE="Courier">&lt;= less than or equal to<BR>&gt;= greater than or equal to<BR>&lt;&gt; not equal to<BR><BR>So, all the following are boolean expressions. This is despitethe fact that all the variables involved are integers. (We coulddraw up similar examples using real numbers too). This can bedifficult to get your head round, but is actually quite obvious.<BR><BR>x=5, y&lt;78, y&lt;=9, z&gt;5, r&lt;&gt;4<BR><BR>and so on. In the first example, although x is an integer, iteither is or isn't equal to 5 - so the output is true or false,i.e. boolean. And the same for all the rest.<BR><BR><BR>7.4 Assigning values to boolean variables<BR><BR>Now, how do we assign the outcomes of these expressions to booleanvariables? We use the &quot;:=&quot;, as before. Note, at thispoint, we have (almost without noticing it) covered the reasonwhy Pascal uses &quot;:=&quot; and not just &quot;=&quot; as anassignment operator; the = sign on its own is used in booleancomparisons. It's a plus point for Pascal that the equals signdoesn't have a confusing dual role like it does in some otherlanguages, though some might consider it too picky. Anyway, theway we assign variables is:<BR><BR>1. Put the boolean expression in brackets: (x=5).<BR><BR>2. Assign the boolean variable this value: a:=(x=5).<BR><BR>This looks confusing because of the two equals signs - which iswhy I covered this operator first. It becomes more obvious whenthe other relational operators are used, e.g. a:=(y&gt;5) andb:=(z&lt;&gt;2). In fact, the brackets are not strictly necessary... but I find a:=x=5 far too confusing! Always use brackets,is a sensible rule. Strictly, it is good practice only to compareintegers with integers, reals with reals, and booleans with booleans(the latter may seem odd, but if a=true and b=true then thereis no reason why (a=b) should not be a boolean operator).<BR><BR>One more boolean operator is odd(x) which is true if x is oddand false is x is even (x has to be an integer, of course). Wecan use this in the same way: a:=(odd(x)) for example, where ais boolean and x is an integer.<BR><BR>So, we can now evaluate a boolean expression and get the resultinto a boolean variable, all in one short expression of the forma:=(x) where a is the boolean variable and x is the boolean expression.But beware! This area is continually confusing. For example, theexpression &quot;a=true&quot; is either true or false; it is NOTan assignment of a value. So x:=(a=true) is true if and only ifa really is true. If a is false, then x is also false. Similarly,x:=(a=false) gives x the value true if a really is false; if ais actually true, then x gets the value false. Always look outfor the difference between &quot;:=&quot; and &quot;=&quot;!<BR><BR><BR>7.5 A first if statement<BR><BR>Now, how about the other way of getting to this place, via ifstatements? Let's take the example a:=(x=5) again. What this reallysays is &quot;if x equals 5 then a is true, otherwise a is false&quot;.We could actually write this as an if statement, as shown in thefollowing macro.<BR><BR>macro 'Does X Equal 5? [D]';<BR>var<BR>&nbsp; &nbsp; &nbsp; x: integer;<BR>&nbsp; &nbsp; &nbsp; a: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; x:=GetNumber('Enter an integer',5,0);<BR>&nbsp; &nbsp; &nbsp; if (x=5)<BR>&nbsp; &nbsp; &nbsp; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a:=true<BR>&nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a:=false;<BR>&nbsp; &nbsp; &nbsp; PutMessage('The value of a is ',a:1:0);<BR>end;<BR><BR>Note the &quot;if .. then .. else ..&quot; structure. The coreof the matter is the following section:<BR><BR>if (x=5)<BR>&nbsp; &nbsp; &nbsp; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a:=true<BR>&nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a:=false;<BR><BR>which is in fact totally equivalent to the more pithy (but lessobvious!) statement &quot;a:=(x=5);&quot;. Look closely at thecode above and you will notice that in &quot;semicolon&quot; termsit is actually a single statement, i.e. it is only terminatedby a semicolon once (Pascal basically ignores carriage returns,remember). From this point onward, I will only be using the &quot;shorthand&quot;way to assign boolean variables, since it takes up much less spacethan the &quot;if statement&quot; way. This will free up the ifstatements to do their true job, which is to make important decisions,i.e. what do we do IF a variable is true or false? The properjob of if statements is to act on boolean expressions, not justto evaluate them. Take a break here, and don't worry about howthe detail of if statements works - we haven't finished with thisyet. We will come back to them from a slightly different angle.<BR><BR><BR>7.6 The basic if structure<BR><BR>Consider this structure:<BR><BR>if x<BR>&nbsp; &nbsp; &nbsp; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<BR>&nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;... ;<BR><BR>Obviously, x is a boolean variable; what is it really saying is&quot;if x is true then do this, otherwise do that&quot; - wherethe second option is equivalent to x being false. Wouldn't itmake more sense to actually encode &quot;if x=true then&quot;?The answer is no, because the &quot;=true&quot; is actually redundant.Since x is an assigned boolean variable, it must be either trueor false already, so there is no point asking &quot;if true=true&quot;or &quot;if true=false&quot; - we are just generating a redundantoperation which will slow down the computer. It may appear strangeat first, especially with expressions like &quot;if flag then&quot;which don't follow a very language-like syntax, but it makes perfectsense. So our basic structure is:<BR><BR>if (boolean expression)<BR>&nbsp; &nbsp; &nbsp; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (command if true)<BR>&nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (command if false) ;<BR><BR>Note that only one of the two options is ever run - the otheris ignored. This is the whole point of a boolean statement.<BR><BR><BR>7.7 More complex if statements<BR><BR>Consider the following macro:<BR><BR>macro 'If [I]';<BR>var<BR>&nbsp; &nbsp; &nbsp; input: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; input:=GetNumber('Enter either zero or one:',1,0);<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; if input <BR>&nbsp; &nbsp; &nbsp; then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('You enteredone, i.e. true.');<BR>&nbsp; &nbsp; &nbsp; end <BR>&nbsp; &nbsp; &nbsp; else begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('You enteredzero, i.e. false.'); <BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>A number of points need to be carefully discussed. First, we havebypassed any boolean calculations: the boolean variable inputjust has a 1 or a 0 assigned to it by the user. The macro thenprints out the appropriate value, not by directly printing &quot;input&quot;but by inferring it from the &quot;if input&quot; statement. Second,here we finally see a situation where you must give the value1 or 0 to a boolean variable. The program will let you input anythingyou like as the value of input, but it will crash at the if statement(giving an error message saying &quot;boolean value expected&quot;)unless a 1 or 0 is used. Note that this would not be the caseif the value of input was just printed out without the computerhaving to &quot;think&quot; about it.<BR><BR>Third, we have &quot;jumped&quot; to an exact parallel with thefor loop structure: we have added a &quot;begin&quot; and &quot;end&quot;after both the &quot;then&quot; and &quot;else&quot; commands,which allows multiple statements to be used. In detail, the simplestructure was:<BR><BR>if (boolean operator)<BR>&nbsp; &nbsp; &nbsp; then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (single command if true)<BR>&nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (single command if false);<BR><BR>The complex structure is:<BR><BR>if (boolean operator)<BR>then begin<BR>&nbsp; &nbsp; &nbsp; (command if true);<BR>&nbsp; &nbsp; &nbsp; (command if true);<BR>&nbsp; &nbsp; &nbsp; (command if true);<BR>end<BR>else begin<BR>&nbsp; &nbsp; &nbsp; (command if false);<BR>&nbsp; &nbsp; &nbsp; (command if false);<BR>&nbsp; &nbsp; &nbsp; (command if false);<BR>end;<BR><BR>Look carefully at the &quot;ends&quot; above. There are two -the first is the &quot;then end&quot;, if you like, and the secondthe &quot;else end&quot;. Only the latter has a semicolon afterit - a semicolon after the then end will cause problems. Despiteall the intermediate commands, it is still basically structuredlike a single command: <BR><BR>if .. then begin .. end else begin .. end;<BR><BR>so it only requires a single semicolon. As with the for loop,any complex operations require the &quot;begin .. end&quot; tobe added, and from now on we will always use them, to make theprogram clearer (so-called &quot;defensive programming - aimingto make it harder for bugs to be encoded in the first place).This &quot;begin .. end&quot; approach will be used for loopstoo. And as for loops, we can also use procedures, instead ofmultiple statements between the begin and end, if desired. Notealso the role of indentation, which is ignored by the computer,but makes the structure of the loops clearer to the human eye.<BR><BR><BR>7.8 Omitting the else part<BR><BR>The &quot;else&quot; section is optional. An &quot;if .. then..&quot; statement without the else will only do anything if itsboolean expression is true; otherwise, it does nothing. The &quot;else&quot;option is equivalent to an empty statement - a semicolon on itsown. An example is below.<BR><BR>macro 'No Else [N]';<BR>var<BR>&nbsp; &nbsp; &nbsp; testvalue: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; testvalue:=1;<BR>&nbsp; &nbsp; &nbsp; if testvalue then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PutMessage('Test Valueis one.');<BR>&nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; PutMessage('This is always printed.');<BR>end;<BR><BR>See how the second dialogue box is always printed? The semicolonafter the first &quot;end&quot; command signals the end of theif statement to the computer, telling it that there is no elsestatement this time, so that if testvalue really is zero thenit can go straight on to the next command after the if structure.Look at the comparison of &quot;with else&quot; and &quot;withoutelse&quot; if statements below, and note the position of the semicolon.<BR><BR>if (boolean operator)<BR>then begin<BR>&nbsp; &nbsp; &nbsp; (command 1 if true);<BR>&nbsp; &nbsp; &nbsp; (command 2 if true);<BR>&nbsp; &nbsp; &nbsp; (command 3 if true);<BR>end <BR>else begin<BR>&nbsp; &nbsp; &nbsp; (command 1 if false);<BR>&nbsp; &nbsp; &nbsp; (command 2 if false);<BR>&nbsp; &nbsp; &nbsp; (command 3 if false);<BR>end;<BR><BR>compared with:<BR><BR>if (boolean operator)<BR>then begin<BR>&nbsp; &nbsp; &nbsp; (command 1 if true);<BR>&nbsp; &nbsp; &nbsp; (command 2 if true);<BR>&nbsp; &nbsp; &nbsp; (command 3 if true);<BR>end;<BR><BR>There is only one semicolon in the &quot;main structure&quot;in both cases, but if an &quot;else&quot; part is needed, thenit must go after the second &quot;end&quot;, WITHOUT a semicolonafter the first &quot;end&quot;. If there is no &quot;else&quot;statement, the semicolon goes after the first &quot;end&quot;.I hope this is clear. It is simpler to omit the else statementunless it is specifically needed.<BR><BR><BR>7.9 Nested ifs and logic puzzles<BR><BR>If statements can be &quot;nested&quot; just like for loops, whenmore than one decision is needed. Look at the following exampleand try to work out under which conditions each message will actuallyget displayed.<BR><BR>macro 'Nested If [N]';<BR>var<BR>&nbsp; &nbsp; &nbsp; bool1: boolean;<BR>&nbsp; &nbsp; &nbsp; bool2: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; bool1:=1;<BR>&nbsp; &nbsp; &nbsp; bool2:=1;<BR>&nbsp; &nbsp; &nbsp; if bool1 then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if bool2 then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PutMessage('Message 1');<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PutMessage('Message2');<BR>&nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; PutMessage('Message 3');<BR>end;<BR><BR>Message 1 will only get displayed if both bool1 and bool2 aretrue - both if statements must be &quot;passed correct&quot; beforeit is reached. In this case, the bool1 if statement will alsobe true, resulting in Message 2 getting printed as well. Message3 comes after both if structures are complete and is thereforealways printed regardless of the truth of bool1 and bool2. Thinkabout the other possibilities. If only bool1 is true, then Message2 and Message 3 will be printed, but not Message 1. If bool2 istrue but not bool1, then the first if statement is not passedand only Message 3 will appear.<BR><BR>This is quite a difficult macro to follow just by looking at thecode - we have to carefully match up each &quot;if .. then begin&quot;with its appropriate &quot;end;&quot;, then we can allocate theother commands to the various if loops. Each &quot;chunk&quot;of code is inserted into the middle of another chunk, rather thanthem following each other in logical order. The computer findsthis easier to follow than the human brain! Indentation and commentsare very useful in following nested if loops. Consider the following:<BR><BR>if a then begin<BR>&nbsp; &nbsp; &nbsp; if b then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if c then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;command 1;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;command 2;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;command 3;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end; {end of if c structure}<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command 4;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command 5;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command 6;<BR>&nbsp; &nbsp; &nbsp; end; {end of if b structure}<BR>&nbsp; &nbsp; &nbsp; command 7;<BR>&nbsp; &nbsp; &nbsp; command 8;<BR>&nbsp; &nbsp; &nbsp; command 9;<BR>end; {end of if a structure}<BR><BR>The strong indenting and comments make it easier to see that ifONLY a is true, and not b or c, then the computer jumps straightto commands 7, 8 and 9 (for example). Note that for every if structure,we use a begin and an end, even if (as in one of the earlier macros)we are only using single commands and could get away without -begin and end markers make understanding the code much easier.They also remove any ambiguity if there is a &quot;dangling else&quot;statement.<BR><BR><BR>7.10 The dangling else problem<BR><BR>Here's another version of the &quot;Message X&quot; puzzle thatwe met above:<BR><BR>macro 'Dangling Else [D]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: boolean;<BR>&nbsp; &nbsp; &nbsp; b: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=0;<BR>&nbsp; &nbsp; &nbsp; b:=1;<BR>&nbsp; &nbsp; &nbsp; if a then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if b then<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PutMessage('Message 1')<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PutMessage('Message 2');<BR>&nbsp; &nbsp; &nbsp; PutMessage('Message 3');<BR>end;<BR><BR>Again, the challenge is to explain which messages will appearunder the different truth conditions. As before, Message 3 isoutside the nested statements and is therefore always printed.Message 1 clearly requires both a and b to be true. But what aboutMessage 2 - who does the &quot;dangling else&quot; belong to?The answer is the &quot;if b&quot; statement, purely because itis the most recent if statement, and this is the rule Pascal uses- it simply goes back through the code until it finds the mostrecent if, and assumes the dangling else belongs to this. So,Message 2 is only printed if a is true and b is false. But byusing begin and end with every if statement, we can avoid thisambiguity. The modified macro becomes:<BR><BR>macro 'New Dangling Else [D]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: boolean;<BR>&nbsp; &nbsp; &nbsp; b: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=1;<BR>&nbsp; &nbsp; &nbsp; b:=0;<BR>&nbsp; &nbsp; &nbsp; if a then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if b then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PutMessage('Message 1');<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PutMessage('Message 2');<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end; {end of if b statement}<BR>&nbsp; &nbsp; &nbsp; end; {end of if a statement}<BR>&nbsp; &nbsp; &nbsp; PutMessage('Message 3');<BR>end;<BR><BR>Now everything is (hopefully) clear. Think very clearly now abouthow we would change the above macro so that the &quot;else&quot;statement above was part of the first if statement - the &quot;ifa&quot; statement. We need to carefully rearrange our begins,ends, and semicolons:<BR><BR>macro 'New Dangling Else 2 [Q]';<BR>var<BR>&nbsp; &nbsp; &nbsp; a: boolean;<BR>&nbsp; &nbsp; &nbsp; b: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; a:=1;<BR>&nbsp; &nbsp; &nbsp; b:=0;<BR>&nbsp; &nbsp; &nbsp; if a then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if b then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PutMessage('Message 1');<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end; {end of if b statement}<BR>&nbsp; &nbsp; &nbsp; end<BR>&nbsp; &nbsp; &nbsp; else begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PutMessage('Message2');<BR>&nbsp; &nbsp; &nbsp; end; {end of if a statement}<BR>&nbsp; &nbsp; &nbsp; PutMessage('Message 3');<BR>end;<BR><BR>This may seem a bit incomprehensible: the main thing to rememberis never to attempt editing or altering any program like this&quot;on the fly&quot; - code must always be constructed fromthe basic structural building blocks of ifs, then add elses, thenadd &quot;begin .. end&quot; pairs and a single semicolon foreach if statement, then add the desired commands in the rightplaces with a semicolon after each. It does look complicated,but it is totally logical!<BR><BR><BR>7.11 The and and not operators<BR><BR>We have seen how if statements use a kind of shortened logic,&quot;if x&quot; really meaning &quot;if x is true&quot; in writtenlanguage. We can use three boolean operators to create more complexboolean expressions for our if statements to evaluate. These operatorsare and, or, and not. In each case, we have a choice about whereto use them - either in the if statement itself:<BR><BR>if (x and y) then ...<BR>if (x or y) then ...<BR>if (not x) then ...<BR><BR>or we can incorporate them into the boolean variables' assignmentsbeforehand:<BR><BR>a:=(x and y)<BR>b:=(x or y)<BR>c:=(not x)<BR><BR>Hopefully you will find them obvious enough to use. The main thingto remember is always to use brackets to keep everything clear;this isn't necessary for single-variable expressions like theabove, but as soon as we are using expressions like<BR><BR>a:=((x&lt;&gt;6) and (y&gt;4))<BR><BR>then the brackets become essential. And, or and not can be usedwith all kinds of boolean expressions like these. The end result,as always, is just a single boolean variable: a true or false.I'm sure you know the definitions already, but just to summarise:&quot;a and b&quot; is true only when both a and b are true; &quot;aor b&quot; is true if either a, or b, or both a and b, are true;&quot;not a&quot; is true if a is false and false if a is true.<BR><BR><BR>7.12 A demonstration of &quot;and&quot; and &quot;or&quot;<BR><BR>The following macros give simple demonstrations of the &quot;and&quot;and &quot;or&quot; operators:<BR><BR>macro 'And Test [A]';<BR>var<BR>&nbsp; &nbsp; &nbsp; input1: boolean;<BR>&nbsp; &nbsp; &nbsp; input2: boolean;<BR>&nbsp; &nbsp; &nbsp; testvalue: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; input1:=GetNumber('Enter input 1:',1,0);<BR>&nbsp; &nbsp; &nbsp; input2:=GetNumber('Enter input 2:',1,0);<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; testvalue:=(input1 and input2); <BR>&nbsp; &nbsp; &nbsp; if testvalue<BR>&nbsp; &nbsp; &nbsp; then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('Both inputswere true.');<BR>&nbsp; &nbsp; &nbsp; end <BR>&nbsp; &nbsp; &nbsp; else begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('One or moreinputs were false.'); <BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>macro 'Or Test [O]';<BR>var<BR>&nbsp; &nbsp; &nbsp; input1: boolean;<BR>&nbsp; &nbsp; &nbsp; input2: boolean;<BR>&nbsp; &nbsp; &nbsp; testvalue: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; input1:=GetNumber('Enter input 1:',1,0);<BR>&nbsp; &nbsp; &nbsp; input2:=GetNumber('Enter input 2:',1,0);<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; testvalue:=(input1 or input2); <BR>&nbsp; &nbsp; &nbsp; if testvalue<BR>&nbsp; &nbsp; &nbsp; then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('At least oneinput was true.');<BR>&nbsp; &nbsp; &nbsp; end <BR>&nbsp; &nbsp; &nbsp; else begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('Both inputswere false.'); <BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR><BR>7.13 Always use brackets<BR><BR>Now, what happens when we combine these operators? For example,what does &quot;not a and b&quot; mean? There is an order of prioritywithin Pascal, such that &quot;not&quot; takes precedence over&quot;and&quot; ... so that the &quot;not&quot; in &quot;not aand b&quot; only applies to a, leaving b unchanged. This can beclarified using brackets: not a and b equals (not a) and b. Sohow exactly does this order of priority work? This is not somethingwe need to know because from now on we will ALWAYS use bracketsin such expressions. User-entered brackets override Pascal's orderof priority, thus giving us complete control: we can specify (nota) and b, or not(a and b), as we wish. The key is to avoid ambiguity,so that we, and everyone else who reads our program, knows whatwe are doing.<BR><BR><BR>7.14 There's no EOR<BR><BR>Note that there is no equivalent to EOR or XOR (&quot;exclusiveor&quot;) in Pascal. This may be needed for a situation wherewe want to know if either a or b, but not both a and b, are true.We just have to write it out the long way, as &quot;(a and notb) or (b and not a)&quot;. The same is true of its opposite, &quot;equivalence&quot;,i.e. both boolean values the same - both true, or both false.We must write this out as &quot;(a and b) or ((not a) and (notb))&quot;. However, all this is getting a bit academic anyway.Our main use will simply be of and, or, and not in basic decision-making.<BR><BR><BR>7.15 nPics<BR><BR>Now is an appropriate time to introduce the variable nPics, whichtells us how many images are currently open. The situation isthis: we have a macro which can only run on one image at a time.How do we check that one, and only one, image is open?<BR><BR>macro 'nPics if [N]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; if (nPics=0) then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PutMessage('This macrorequires one image to be open.');<BR>&nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; if (nPics&gt;1) then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PutMessage('This macrorequires only one open image at a time.');<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>Note that although nPics is an integer variable (I presume!),it does not have to be initiated, so this macro does not requirea &quot;var&quot; section. Rather than one, general, error message,this macro implements two which are slightly differently wordeddepending on the situation. They are controlled by if statementswithout elses - if nPics=1, then all the commands are just ignored.I hope this is obvious enough.<BR><BR><BR>7.16 Let's recap<BR><BR>That was a very long chapter. If you got to here and are stillnot sure, best to go and work through it again more slowly. Remember,you have to understand boolean expressions before you can understandif statements.</FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><FONT FACE="Courier"><BR><BR></FONT><A NAME="anchor305217"></A><B><TT><FONT FACE="Courier">8.Repeat and while loops</FONT></TT></B><FONT FACE="Courier"><BR><BR>8.1 Introduction to conditional loops<BR><BR>Here we cover conditional loops - &quot;repeat&quot; and &quot;while&quot;loops. These combine the features of for loops and if statements.As we know, for loops have to be executed a preordained numberof times; if statements bring choice into the program but canonly execute an option once. Conditional loops allow us to makedecisions within the program about how many times a loop shouldbe repeated, so they allow programs to be more versatile.<BR><BR><BR>8.2 Basic structure of the repeat loop<BR><BR>The repeat loop has the following structure:<BR><BR>repeat<BR>&nbsp; &nbsp; &nbsp; action 1;<BR>&nbsp; &nbsp; &nbsp; action 2;<BR>&nbsp; &nbsp; &nbsp; action 3;<BR>until x;<BR><BR>where actions 1-3 are the loop commands, which are to be repeated,and x is a boolean expression as with if statements - it is eithertrue or false (and this boolean expression can incorporate allthe logical complexity we covered with if statements, if required).When the repeat statement is encountered, the computer executesthe actions, then checks to see whether the &quot;exit condition&quot;x is met, i.e. is true. If it is, then the computer moves on tothe rest of the program. If the exit condition is not met, i.e.false, then the actions are repeated and the check redone. Thisrepeats until the exit condition is met - as many loops as isnecessary! The first important thing to remember is that the actionswill always be executed once, even if the exit condition is truebefore the repeat loop is even encountered. Only their repeatsare dependent on the value of the exit condition. Note also thatthe fundamental structure, as with the if statement, is basedon a single line terminated by a single semicolon:<BR><BR>repeat ... until x;<BR><BR>8.3 An example of a repeat loop<BR><BR>Below is an example repeat loop in a macro.<BR><BR>macro 'Repeat [R]';<BR>var<BR>&nbsp; &nbsp; &nbsp; input: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; input:=GetNumber('Enter an integer less than20:',5,0);<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; repeat<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn(input);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input:=input+1;<BR>&nbsp; &nbsp; &nbsp; until (input=20);<BR>&nbsp; &nbsp; &nbsp; WriteLn('Exit condition met.');<BR>end;<BR><BR>This inputs and prints an integer, then prints the integers greaterthan this, up to a maximum value of ... 19. Note this: 19, not20 - the exit condition is that input is equal to 20, so an outgoingvalue of 20 exits the loop without going back to the printingroutine at the start. If we were to change<BR><BR>WriteLn(input);<BR>input:=input+1;<BR><BR>to<BR><BR>input:=input+1;<BR>WriteLn(input);<BR><BR>then the printed output would go up to 20, but the initial valuewould not be printed. Make sure you understand this. Care is neededin situations like this where the order of commands is crucial.<BR><BR><BR>8.4 Infinite loops<BR><BR>There is an obvious weakness in this program. If we enter an integergreater than 20, or 20 itself (since it will be incremented to21 before the exit condition is tested, which will result in a&quot;false&quot; result), then the exit condition will neverbe met, and the variable &quot;input&quot; will keep on increasingin value indefinitely! This &quot;infinite loop&quot; possibilitymust be considered whenever repeat loops are used - the generalrule is that something within the actions must in some way modifythe exit condition so that it is eventually made true.<BR><BR>We could pre-empt this problem in the macro above in two ways.First, we could add a check on the value of input when it is firstentered - an if statement which gives an error message if thevalue is 20 or greater. Or, more elegantly, we could change theexit condition on the repeat statement to be (input&gt;=20) ratherthan (input=20); this would also prevent an infinite upward sequence.However, the weakness was left in the program to illustrate howto handle infinite loops when they &quot;slip through&quot; theprogram design. So what happens when we enter a value of 20 ormore into the macro?<BR><BR>The macro begins printing its infinite sequence, but in fact stopsafter about 15 seconds (on an iMac), having reached a value ofabout 660, because the output in the text window exceeds the 32klimit on text files. Alternatively, we can interrupt the infiniteloop earlier by pressing CTRL-APPLE-. and holding them down forsufficiently long so that a &quot;break&quot; in the program isreached.<BR><BR><BR>8.5 Waiting for user input using repeat loops<BR><BR>As a final point, we can also use repeat loops to wait for theuser to press a certain key. For example:<BR><BR>macro 'Beep After Click [B]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; repeat until button;<BR>&nbsp; &nbsp; &nbsp; Beep;<BR>&nbsp; &nbsp; &nbsp; PutMessage('You have just pressed the mousebutton.');<BR>end;<BR><BR>You may recall that we met a version of this macro in the secondchapter. We can also wait for one of the &quot;shift&quot; keysto be pressed:<BR><BR>macro 'Beep After Shift [B]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; repeat until KeyDown('shift');<BR>&nbsp; &nbsp; &nbsp; Beep;<BR>&nbsp; &nbsp; &nbsp; PutMessage('You have just pressed &quot;shift&quot;.');<BR>end;<BR><BR>We can also detect the &quot;option&quot; and &quot;control&quot;keys using the KeyDown command above (which is a boolean function).Bear in mind that the rest of the macro is &quot;frozen&quot;until the exit condition is met. The mouse click control routinecan be extremely useful in interactive macros.<BR><BR><BR>8.6 Introduction to while loops<BR><BR>The &quot;while&quot; loop is very similar to the &quot;repeatloop&quot; - again, it is conditional. Here, however, there isan &quot;entry condition&quot; rather than an &quot;exit condition&quot;.This means that the &quot;flow&quot; through the loop is different.When the while statement is first encountered, the entry condition(a boolean expression) is evaluated, and if it is false, the wholewhile loop is ignored. If it is true, then the while loop is executed,then the computer re-evaluates the entry condition. The loopingcontinues until the entry condition is calculated as false.<BR><BR><BR>8.7 Structure of while loops<BR><BR>So immediately we can see the key difference between repeat loopsand while loops - it is possible that a while loop will not beexecuted at all, whilst a repeat loop will always be executedat least once. The basic structure of a while loop is as follows:<BR><BR>while x do begin<BR>&nbsp; &nbsp; &nbsp; action 1;<BR>&nbsp; &nbsp; &nbsp; action 2;<BR>&nbsp; &nbsp; &nbsp; action 3;<BR>end;<BR><BR>where actions 1-3 are the commands within the loop which are repeated,and x is a boolean expression: the entry condition. If x is falseat the first evaluation, the whole while loop is ignored. If itis true, the actions are repeated until it finally turns out false.Note once again the &quot;single line, single semicolon&quot;structure:<BR><BR>while .. do begin .. end;<BR><BR>and note also the possibility once more of an infinite loop ifthe actions do not in some way affect the entry condition. Thesame &quot;rule&quot; as mentioned for repeat loops applies towhile loops also, in order to stop infinite repetition: the actionswithin the loop must somehow modify the entry condition.<BR><BR><BR>8.8 An example of a while loop<BR><BR>Here is an example of a while loop in a macro.<BR><BR>macro 'While [W]';<BR>var<BR>&nbsp; &nbsp; &nbsp; input: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; input:=GetNumber('Enter a number less than10',5,0);<BR>&nbsp; &nbsp; &nbsp; NewTextWindow('Macro Output');<BR>&nbsp; &nbsp; &nbsp; while (input&lt;=10) do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('Entry conditionmet...');<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn(input);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input:=input+1;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteLn('Ending whileloop...');<BR>&nbsp; &nbsp; &nbsp; end; {end of while loop}<BR>&nbsp; &nbsp; &nbsp; WriteLn('Entry condition failed...');<BR>&nbsp; &nbsp; &nbsp; WriteLn('End of macro.');<BR>end;<BR><BR>Note the comment indicating that the &quot;end&quot; in the middleof the macro is linked to the while statement - not really neededhere, but useful to have in more complex code.<BR><BR><BR>8.9 Comparison of repeat and while loops<BR><BR>While statements are particularly useful in detecting &quot;crazy&quot;values like -9999 that may be used in data to mark missing valuesor the ends of defined intervals, for example, via loops like:<BR><BR>while (x&lt;&gt;-9999) do begin ... end;<BR><BR>Of course, a repeat loop could also be used, of the form:<BR><BR>repeat ... until x=-9999; <BR><BR>Repeat and while often overlap in this way, and there are no generalguidelines for choosing which to use. The two questions we needto ask are: first, does the loop always need to be executed atleast once, or can we get away with it sometimes never being executed?And second, would it be easier to have an exit condition, whichcauses the loop to stop when it is true, or an entry condition,which causes the loop to repeat when it is true? In many situationseither can be used just as well. But consider this example:<BR><BR>repeat ... until ((not a) or (not b))<BR><BR>versus<BR><BR>while (a and b) do ...<BR><BR>The two versions are logically equivalent, but the &quot;while&quot;version is obviously a lot easier for a human to follow. In general,it is simpler to use a &quot;while&quot; loop if you find yourselfwriting a &quot;repeat until not&quot;-type loop. But as I saidabove, often either will do. Why not work out both while and repeatversions and see which looks best?<BR><BR><BR>8.10 A word on multiple boolean expressions<BR><BR>Finally, note that using &quot;or&quot; as part of an exit orentry condition can cause problems of ambiguity, since no recordis preserved of which part(s) of the or statement were actuallytrue, i.e. what the precise reason was for the loop being exitedor entered. If you type &quot;repeat ... until (a&gt;0 or b&gt;0)&quot;then when the loop stops, you won't know which variable(s) areindeed positive, just that one or more of them is. Another ifstatement is needed straight away afterwards, to give us the completepicture: was it a, b, or both?<BR><BR>Another more general note along this line is that every statementin a multiple boolean expression is always evaluated, which canresult in some programs becoming inefficient. It's better to splitthem up as much as possible, which also makes the program easierto follow. Instead of using &quot;if a and b and c or d... etc&quot;then use multiple nested if statements, such that if a is false,then the computer doesn't have to worry about b, c, d, and soon, because it can jump through to the end of the if structure.This applies to repeat and while loops as well - better to nestthem than to let things get complex and unreadable.<BR><BR><BR>8.11 A language summary<BR><BR>We've now covered the basic language elements: for, if, repeat,and while. Combining these allows a huge diversity of macros tobe written. Practice writing simple macros that use them, andhave another look at the supplied macros. If you are keen, youcould also look at the source code of NIH Image, which is availablefrom <BR><BR>ftp://rsbweb.nih.gov/pub/nih-image/source/<BR><BR>and other Pascal programs, to find more programming inspiration.The rest of this manual is very specific to NIH Image and muchless so to general Pascal.</FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor305769"></A><B><TT><FONT FACE="Courier">9.Arrays</FONT></TT></B><TT><FONT FACE="Courier"><BR><BR>9.1 Introduction to arrays in Pascal<BR><BR>Arrays are &quot;structured variables&quot;: they can containmore than one value, and each value is stored in a specific location.Arrays are &quot;random access&quot;, which means that we canaccess any of the component values - we don't need to cycle throughthem in a specific order, for example. We needn't worry abouthow the computer stores array values and keeps track of them.All we need to know is the notation for accessing the values.In Pascal, if we have an array called ArrayName with 10 values,then the first value is<BR><BR>ArrayName[1]<BR><BR>and the 10th value is<BR><BR>ArrayName[10]<BR><BR>Basically, we use square brackets [] to enclose the appropriate&quot;subscript&quot; (the address in the array) of the desiredarray &quot;element&quot;. To go through the terminology again:an array is a variable, made up of elements, each of which canbe accessed using the appropriate subscript in square brackets.Now, that's as far as we need to go with arrays in Pascal. Notfar at all! This is because arrays in NIH Image are very specialised,and their handling doesn't involve &quot;standard&quot; Pascalarray commands. So from now on we will be concentrating specificallyon NIH Image arrays.<BR><BR><BR>9.2 The NIH Image user arrays: rUser1 and rUser2<BR><BR>We cannot define our own arrays in NIH Image. We have to use thelimited selection of arrays that are already defined by the program.All of these predefined arrays are used by the program in storingdata, during the normal (non-macro-based) operation of NIH Image,except for two which are specifically reserved for macro users.These are named rUser1 and rUser2, and we will be concentratingon these, at first. They are both &quot;linear&quot; arrays, withelements accessed via a single subscript. So, we can write valuesto these arrays using &quot;:=&quot; like this:<BR><BR>rUser1[3]:=5<BR>rUser2[1]:=3.142<BR>rUser1[x]:=4.2<BR>rUser2[i+5]:=x<BR><BR>and we can read values from them in the same way:<BR><BR>x:=rUser1[1]<BR>y:=rUser2[5]<BR>z:=rUser1[i]<BR><BR>and so on. It appears that all the values are stored as real numbers,i.e. the type of the array variable is &quot;real&quot;. Essentially,rUser1 and rUser2 are just two lists of numbers which we can modifyat our will. Displaying their contents is a little more involved- read on.<BR><BR><BR>9.3 How the non-user arrays work: rCount<BR><BR>The arrays in NIH Image are there to store results from measuringimages, so array output is displayed in the &quot;Results&quot;window. The arrays record different aspects of the single regionof interest (ROI) which is being measured. (See chapter 11 forcoverage of ROIs in more detail). We need to really understandthis, before we can know how array subscripts work.<BR><BR>The ordinary (&quot;non-user&quot;) arrays are there to containresults like &quot;area of ROI&quot;, &quot;mean greyvalue ofROI&quot;, &quot;maximum greyvalue in ROI&quot;, &quot;minimumgreyvalue in ROI&quot;, &quot;length of ROI&quot;, and so on.When the user clicks on &quot;Analyze&quot; then &quot;Measure&quot;,having already selected a ROI, then each of these arrays has aresult assigned to it. Visualise the results from the first ROImeasurement: the area goes into Area[1], the mean into Mean[1],the minimum greyvalue into Minimum[1], and so on (the array namesaren't exactly right, but it doesn't matter). Then, say a differentROI is selected and measured. A whole new spread of results isgenerated, and these go into the element [2] ... so the mean goesinto Mean[2], then area into Area[2], and so on. This assignmentis all done remotely, by the program itself. So now we have thekey question - how does NIH Image know where to put the results,in order to avoid overwriting previous measurement data? Resultsdata are placed into the next available element of each array- this subscript will be the same across all the results arrays,since a complete set of results is always generated for each &quot;Measure&quot;command. The subscript is controlled by a counter variable calledrCount.<BR><BR><BR>9.4 How rCount works<BR><BR>The variable rCount is increased by one, automatically, followingeach &quot;Measure&quot; operation. So, picture a user makingmeasurements on NIH Image, not using macros, just the standardprogram's features. rCount is initially 1. The first ROI is selectedand the &quot;Measure&quot; command issued. A whole set of resultsis generated and placed into Area[rCount], Mean[rCount] and soon, which is equal to Area[1], Mean[1], etc. At the end of thisoperation, rCount is automatically incremented, giving it a valueof 2. Say the user then does another measurement, on a new ROI.The results set generated go into Mean[rCount], Area[rCount],and so on, again, but this time rCount is 2, so the next elementin each array is used. And so on and so on, until all the measurementsare done.<BR><BR><BR>9.5 Displaying the contents of the rUser arrays<BR><BR>The rCount variable is applied to rUser1 and rUser2 as well -but only for display. What this means is that from within a macro,we can access any elements of rUser1 and rUser2 that we like,changing them as we please - but as soon as we want to DISPLAYthe contents of rUser1 and rUser2, we need to consider what rCountis doing. Let's use a simple macro to show this.<BR><BR>The first thing we need to do is to tell the computer we willbe using only rUser1 out of all the arrays. We do this using<BR><BR>SetOptions('User1');<BR><BR>Note that we use 'User1', not 'rUser1' - potentially confusing!When assigning or reading values to or from rUser arrays, we mustalways have the &quot;r&quot; at the start. We can attach a labelto this array, which will appear at the top of the Results windowoutput:<BR><BR>SetUser1Label('Results');<BR><BR>Now we can assign a value to the first element in the array:<BR><BR>rUser1[1]:=5;<BR><BR>And we can display the Results window (which is there just tooutput arrays - it could alternatively be referred to as the Arraywindow, I suppose) using<BR><BR>ShowResults;<BR><BR>However, if we put all these commands together, the macro doesn'twork - the Results window comes up blank. This is because theShowResults command depends on rCount, which has not been assigneda value. ShowResults displays all results from the arrays definedusing SetOptions('..'), UP TO and including the elements numberedrCount. So to display our value, we need to set rCount equal to1, using the SetCounter command:<BR><BR>SetCounter(1);<BR><BR>Note that we don't use rCount:=1; we have to use this specialcommand instead. Our complete macro is now:<BR><BR>macro 'Array Test [A]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetOptions('User1');<BR>&nbsp; &nbsp; &nbsp; SetUser1Label('Results');<BR>&nbsp; &nbsp; &nbsp; rUser1[1]:=5;<BR>&nbsp; &nbsp; &nbsp; SetCounter(1);<BR>&nbsp; &nbsp; &nbsp; ShowResults;<BR>end;<BR><BR>This produces the output:<BR><BR>&nbsp; &nbsp; &nbsp; Results<BR><BR>1. &nbsp; &nbsp; 5.00<BR><BR>in the Results window. Basically, the output is a list of numbers,with the label of the rUser1 array at the top, and the subscriptnumbers at the left. The two decimal places seems to be a fixednumber. <BR><BR><BR>9.6 Using both user arrays<BR><BR>We can make this clearer by bringing in rUser2 as well. Look atthe following macro.<BR><BR>macro 'Two Array Test [A]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetOptions('User1User2');<BR>&nbsp; &nbsp; &nbsp; SetUser1Label('Left');<BR>&nbsp; &nbsp; &nbsp; SetUser2Label('Right');<BR>&nbsp; &nbsp; &nbsp; rUser1[1]:=5;<BR>&nbsp; &nbsp; &nbsp; rUser1[2]:=6.35;<BR>&nbsp; &nbsp; &nbsp; rUser1[3]:=4.28;<BR>&nbsp; &nbsp; &nbsp; rUser1[4]:=7;<BR>&nbsp; &nbsp; &nbsp; rUser1[5]:=0.89;<BR>&nbsp; &nbsp; &nbsp; for counter:=1 to 5 do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rUser2[counter]:=counter+4;<BR>&nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; SetCounter(5);<BR>&nbsp; &nbsp; &nbsp; ShowResults;<BR>end;<BR><BR>Here we select both rUser1 and rUser2 for use, using the string'User1User2'; note that there is no space between them. We thenlabel the columns 'Left' and 'Right', then assign values to thearray elements directly (for rUser1) and indirectly, via a forloop (for rUser2). Before we display the results, we have to issuethe command<BR><BR>SetCounter(5)<BR><BR>so that the Results window will display the first five elementsof both arrays. If we didn't do this, the values would still bethere, unchanged, but they wouldn't show up! Note that the variable&quot;counter&quot; in the above macro is not connected to the&quot;SetCounter&quot; command in any way. The output of &quot;TwoArray Test&quot; is shown below.<BR><BR>&nbsp; &nbsp; &nbsp; Left &nbsp; &nbsp; Right<BR><BR>1. &nbsp; &nbsp; 5.00 &nbsp; &nbsp; 5.00<BR>2. &nbsp; &nbsp; 6.35 &nbsp; &nbsp; 6.00<BR>3. &nbsp; &nbsp; 4.28 &nbsp; &nbsp; 7.00<BR>4. &nbsp; &nbsp; 7.00 &nbsp; &nbsp; 8.00<BR>5. &nbsp; &nbsp; 0.89 &nbsp; &nbsp; 9.00<BR><BR>It's not hard to see how this table would fit onto an Excel spreadsheet.<BR><BR><BR>9.7 Using rCount to put results into arrays<BR><BR>We don't need the rCount variable if we are just ASSIGNING valuesto array addresses. We could use any integer variable. But isis easiest to use rCount as a counter, because in order to displaythe results properly, we need to keep rCount updated anyway, eachtime we add a new measurement. Now: how can we assign values tothe rUser arrays when we don't know in advance how many valuesare going to be assigned? We can't use a for loop - that wouldrequire us to know how many values were going to be needed. Arepeat (or while) loop is the answer.</FONT></TT> <TT><FONT FACE="Courier">Wehave to increment rCount after each assignment, then repeat, toavoid overwriting previous values, until we have all that we need.A rough routine for this sort of measurement would be structuredlike this:<BR><BR>1. rCount starts at value x<BR>2. Generate the result values and output them to rUser1 and 2<BR>3. Show results<BR>4. Increase rCount to x+1<BR>5. Repeat if necessary<BR><BR>To redo one measurement, we can just reduce rCount by one andrepeat: the previous value will be overwritten. In this sense,rCount is like a cursor on a written document. And if we wantto clear all the data, we can reset rCount to one - its initialvalue - ready to start recording again from the beginning. Wedo this using the &quot;ResetCounter&quot; command, which is equivalentto SetCounter(1). How high can rCount go? It can range from 1to 256, so rUser1 and rUser2 can both contain 256 values at maximum.So, this potentially gives us the capability to store and edita large number of image measurements (or result values from somewhereelse) in the rUser arrays. We'll look at a macro that does thisin the next chapter.<BR><BR><BR>9.8 Saving the array data and loading it into Excel<BR><BR>Next we need to know how to export the contents of the user arrays.The easiest way should be to select the Results window, then copyand paste the columns into Excel. Unfortunately, this doesn'twork! Instead, we have to save the data from within the macro.We use Export('File Name') to bring up a &quot;Save Data&quot;dialogue box, in which the suggested file name will be 'File Name'(although it can be changed by the macro user). The user willhave to specify a destination for the save. Now, there are a numberof options concerning which data to save. The contents of rUser1and rUser2 are classed as &quot;Measurements&quot;, so this isthe correct radio button (at the bottom of the dialogue box) topress. Trying other options, e.g. &quot;raw data&quot;, will resultin an error. Now, we cannot force the &quot;Measurements&quot;button to be pressed, but we can make sure that it is at leastpressed when the box first appears, using the SetExport command.So this is our (necessarily imperfect) save routine:<BR><BR>SetExport('Measurements');<BR>Export('Arrays');<BR><BR>All the user needs to do, then, is to click &quot;Save&quot;,and an NIH Image &quot;TEXT&quot; file will be created with theresults in. This is space-delimited data, and it can be loadedinto Excel using the Text Import Wizard.<BR><BR><BR>9.9 The other arrays<BR><BR>So, now we know how to set up, manipulate, and save the rUser1and rUser2 arrays. We can store 512 results values in these, andeasily output them in columns - much better than trying to copewith 512 separate variables. But we must be aware of what thecounter is doing, as soon as we start doing &quot;automatic&quot;measurements, in order to avoid overwriting any data.<BR><BR>The next step is to look at the other arrays offered by NIH Image.These all have some role to play in the ordinary operation ofthe program, but we can bend them to the will of our macros, providingwe know what we are doing. I won't go into more detail here: detailsof the other arrays are available in the main NIH Image manualin Appendix A. The thing to watch is that these arrays are automaticallyoverwritten when measurements are made. So you really have toknow what you are doing, if you plan to store other numbers inthem.<BR><BR><BR>9.10 The LineBuffer array<BR><BR>This is where NIH Image stores the data from the pixels in animage. So it's a pretty big array! Any image processing work thatwe do will generally involve the LineBuffer array. We'll coverit in more detail in chapter 11. For now, just remember that thebasic principles of array elements and addresses apply to it justas they do to rUser1 and rUser2.</FONT></TT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor306408"></A><B><TT><FONT FACE="Courier">10.Introduction to image measurement</FONT></TT></B><FONT FACE="Courier"><BR><BR>10.1 Image measurement and image processing<BR><BR>I make a (simplistic) division between two kinds of basic thingsyou can do with NIH Image. The first is image measurement, whereyou basically leave the image unchanged, and just describe whatit contains: areas, lines, points, etc. The second is image processing,which involves getting at the image pixels themselves and manipulatingtheir values. This includes sharpening the contrast, edge detection,thresholding, noise removal, etc. This chapter of the manual isa brief introduction to image measurement; the next chapter ison image processing.<BR><BR><BR>10.2 Creating a new image file<BR><BR>To create a new image file, click &quot;File&quot;, then &quot;New&quot;,then click the image radio button and enter a name. The new imagewill have the default size of 552 by 436 pixels unless changed.This is analogous to a text file - it can be saved, edited, reloaded,etc.<BR><BR><BR>10.3 The MakeNewWindow command<BR><BR>We can also create a new image within a macro, using the MakeNewWindowcommand:<BR><BR>macro 'Make New Window [M]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; MakeNewWindow('New Image Window');<BR>end;<BR><BR>and we can change the size of the image that we want by usingSetNewSize(x,y) where x is the width and y is the height, in pixels.So this macro creates a 100 by 200 window:<BR><BR>macro 'Make Small Window [S]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetNewSize(100,200); <BR>&nbsp; &nbsp; &nbsp; MakeNewWindow('New Image Window');<BR>end;<BR><BR>The SetNewSize command appears to be &quot;global&quot;, in thatonce the above macro has been run, the default new window sizechanges to 100 by 200, and all new windows are set to this sizeuntil another SetNewSize command is used.<BR><BR><BR>10.4 Image coordinates<BR><BR>NIH Image uses Cartesian coordinates to &quot;map&quot; an image,with the origin in the TOP LEFT HAND CORNER. This is not the sameas the X and Y numbers which are updated in the Info window! These,more familiarly, are based on an origin in the bottom left handcorner. But for all our image processing macros, we will be workingfrom the top left. We can illustrate the coordinate arrangementusing MoveTo(x,y) which moves the &quot;current location&quot;to (x,y), and LineTo(x,y) which draws a line from the currentlocation to (x,y). This is most clearly explained by referenceto the following macro, which draws in the diagonals of a squareimage window.<BR><BR>macro 'Draw Cross [D]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetNewSize(400,400); <BR>&nbsp; &nbsp; &nbsp; MakeNewWindow('New Image Window');<BR>&nbsp; &nbsp; &nbsp; MoveTo(0,0);<BR>&nbsp; &nbsp; &nbsp; LineTo(400,400);<BR>&nbsp; &nbsp; &nbsp; MoveTo(400,0);<BR>&nbsp; &nbsp; &nbsp; LineTo(0,400);<BR>end;<BR><BR>The four corners of the square image have the following coordinates:<BR><BR><BR>(0,0)..............(400,0)<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;.<BR>(0,400)..........(400,400)<BR><BR><BR>10.5 The random lines macro<BR><BR>You might think that coordinates would have to be integers - thereis no &quot;half a pixel&quot;, right? True, but NIH Image doesin fact allow coordinates with decimals - it just rounds themoff to integers. This allows a primitive macro to be written thatdraws random lines on a new square image. The command &quot;random&quot;,which needs nothing following it, generates a random real numberbetween 0 and 1; if we multiply our x and y coordinates by randomcoefficients (which we can do &quot;in situ&quot; in the LineToand MoveTo commands, as with other commands), then we get a wholeload of random lines - very artistic.<BR><BR>macro 'Random Lines [L]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetNewSize(500,500);<BR>&nbsp; &nbsp; &nbsp; MakeNewWindow('Random Lines');<BR>&nbsp; &nbsp; &nbsp; for counter:=1 to 100 do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MoveTo(random*500,random*500);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LineTo(random*500,random*500);<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR><BR>10.6 The main project: a point-measuring macro<BR><BR>The rest of this chapter will give a &quot;walk-through&quot;commentary on how to write a macro to do a simple, but useful,task. The user moves the mouse pointer over an image, and clickson a feature, and the location of this feature is recorded inthe rUser arrays (in terms of x and y pixel coordinates). Up to256 points can be located in this way. We also want to build inan undo feature, and a save feature.<BR><BR><BR>10.7 SetCursor and GetMouse<BR><BR>First we need to set the cursor to a cross, to allow accuratepositioning; we do this using:<BR><BR>SetCursor('cross');<BR><BR>and it will stay in this shape until we change it back to an arrow(by using 'arrow' instead of 'cross'; 'watch' or 'finger' arethe other options, for interest's sake). Then we wait until themouse button is pressed, then use<BR><BR>GetMouse(MouseX,MouseY);<BR><BR>which assigns the x and y coordinates of the mouse pointer, atthe time of the click, to the integer variables MouseX and MouseY(which we have to type-assign beforehand, of course). Now, asusual, these coordinates are calculated from the top left handcorner of the image. But - this is important - they are not limitedto the area of the image. A click above the top of the image willjust give a negative y coordinate, and a click to the left ofthe left hand side of the image will give a negative x coordinate.Clicking in the top left hand corner of the monitor screen willresult in both coordinates being negative. But there will notbe an error message. The GetMouse command covers the whole screen- it only complains if there is not an active image window open.This window doesn't have to be on &quot;top&quot; of the desktop,and nor does the click have to be within the image boundaries.So we have to be careful of nonsense results. <BR><BR><BR>10.8 Reading a single mouse position<BR><BR>We then choose rUser1 and rUser2 as our results arrays, and labelthem for the X and Y coordinates respectively:<BR><BR>SetOptions('User1User2');<BR>SetUser1Label('Mouse X');<BR>SetUser2Label('Mouse Y');<BR><BR>Then we can assign the coordinate values, set the display counterappropriately, and display them:<BR><BR>rUser1[1]:=MouseX;<BR>rUser2[1]:=MouseY;<BR>SetCounter(1);<BR>ShowResults;<BR><BR>So, the whole macro so far, which reads the coordinates of a singlemouse click into the rUser arrays and displays the results, is:<BR><BR>macro 'One Mouse Click [M]';<BR>var<BR>&nbsp; &nbsp; &nbsp; MouseX: integer;<BR>&nbsp; &nbsp; &nbsp; MouseY: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetCursor('cross');<BR>&nbsp; &nbsp; &nbsp; repeat until button;<BR>&nbsp; &nbsp; &nbsp; GetMouse(MouseX,MouseY);<BR>&nbsp; &nbsp; &nbsp; SetOptions('User1User2');<BR>&nbsp; &nbsp; &nbsp; SetUser1Label('Mouse X');<BR>&nbsp; &nbsp; &nbsp; SetUser2Label('Mouse Y');<BR>&nbsp; &nbsp; &nbsp; rUser1[1]:=MouseX;<BR>&nbsp; &nbsp; &nbsp; rUser2[1]:=MouseY;<BR>&nbsp; &nbsp; &nbsp; SetCounter(1);<BR>&nbsp; &nbsp; &nbsp; ShowResults;<BR>end;<BR><BR>This may not seem like much, but it's an important first stepin our project. It's always a good idea to get a simple routinelike this working first, then move on to a more complex program.<BR><BR><BR>10.9 A repeat loop for multiple mouse clicks<BR><BR>The next step is to be able to record the coordinates of multiplemouse clicks, by using the higher addresses in the rUser arrays(and keeping the same labels: rUser1 is X, and rUser2 is Y). Now,we know that the maximum size of the rUser arrays is 256, so weneed a counter that goes up to 256 then stops. We could use afor loop for this, but later on we'll be dealing with open-endednumbers of clicks, so right from the start we will use a &quot;repeat... until&quot; structure.<BR><BR>macro 'Measure Positions v.1 [M]';<BR>var<BR>&nbsp; &nbsp; &nbsp; MouseX: integer;<BR>&nbsp; &nbsp; &nbsp; MouseY: integer;<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; counter:=1;<BR>&nbsp; &nbsp; &nbsp; SetOptions('User1User2');<BR>&nbsp; &nbsp; &nbsp; SetUser1Label('Mouse X');<BR>&nbsp; &nbsp; &nbsp; SetUser2Label('Mouse Y');<BR>&nbsp; &nbsp; &nbsp; ShowResults;<BR>&nbsp; &nbsp; &nbsp; repeat<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetCursor('cross');<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repeat until button;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetMouse(MouseX,MouseY);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait(0.5);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rUser1[counter]:=MouseX;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rUser2[counter]:=MouseY;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetCounter(counter);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UpdateResults;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counter:=counter+1;<BR>&nbsp; &nbsp; &nbsp; until counter=257;<BR>end;<BR><BR>So, the variable counter starts off as 1, and is incremented witheach pass through the repeat loop, until the exit condition (counter=257)is true. Why 257? Look carefully at the location of the counter:=counter+1statement ... right at the end of the repeat loop. Clearly, thefinal pass through the loop will be when counter=256, then whenit gets incremented right at the end, the exit condition willbecome true. So the program will measure up to the 256th click,then stop. I think it is clear why we only get 256 clicks recordedeven though the exit condition uses counter=257. (In fact, it'sunlikely that many people would want to measure that many pointson an image - but it's best to make the program robust in thisway).<BR><BR><BR>10.10 Some features to note<BR><BR>Note also that the SetCursor command must be inside the repeatloop - otherwise the cursor spends most of its time as a watch.This is because of the wait(0.5) command after GetMouse - waithalf a second. It is the wait which causes the (automatic) changeof cursor to a watch ... so why do we need to wait in the firstplace? This is because NIH Image is so quick (in this simple program,anyway!) that a single click means that it rushes through therepeat loop and back to the &quot;repeat until button&quot; commandbefore your finger has released the mouse button from the firstclick! In fact, on my iMac, each single click is long enough forthe computer to whizz round the repeat loop about 8 times! So,without the wait command, each click registers as 8 clicks inthe same location. This is a very strange bug - it's hard to linkthe symptoms with the cause. But it is quite common - it's usefulto deliberately slow down the computer sometimes just so you cansee what it is doing.<BR><BR>So, we use &quot;counter&quot; to address both arrays, and inthe SetCounter command for display. Now read through the wholemacro, making sure you understand why each command is there. Notethe results display commands. After setting the column labels,we use ShowResults to bring up the Results window (even thoughit is blank at this stage). Then after each click we use UpdateResults,which adds only the last measurement to the Results window. Thisis better than just using &quot;ShowResults&quot; each time, sinceit scrolls the window if it gets too small - ShowResults doesnot (although the data is still &quot;there&quot; - this is adisplay issue only).<BR><BR><BR>10.11 Forcing clicks to be within the image area<BR><BR>This is a fairly versatile program, but we still have a problemwith &quot;impossible&quot; locations. If you're above or leftof the image area, then one of the coordinates will be negative,which is obvious enough, but if you're below it or to the right,you need to know exactly how big the image is, in order to knowwhen the click is within its area. We can do this using<BR><BR>GetPicSize(width,height);<BR><BR>then checking that MouseX and MouseY are not negative, and arenot greater than the width or height respectively. If they are,then we can put out an error &quot;beep&quot;, then allow theuser to click again for that particular measurement. Sorting outthis problem lengthens the program so much that things start toget complicated. So, I've removed part of the code into a procedure.Look closely at the macro below - it does the same as the oneabove, but forces all the registered clicks to be within the imagearea. Those that aren't, have to be redone.<BR><BR>At each click, the OutOfBounds boolean condition is evaluated(it's in the procedure). Then, if it is true, the while loop forcesanother run through the measuring procedure, without updatingthe counter - so the previous coordinates are replaced. The macrojust beeps and the top screen bar flashes to indicate that theclick &quot;won't go&quot;.<BR><BR><BR>10.12 An exit option<BR><BR>We have another major issue to solve. Say the user wants to stopbefore measurement 256? The only way he can do so, so far, isto hold down control-apple-. and press the mouse button at thesame time - quite a test of dexterity! We can use the KeyDownboolean function to detect whether one of the shift keys is depressedimmediately after the repeat until button command. If this booleancondition is true, then we can build in an &quot;exit&quot; commandwhich will stop the macro. The simple exit operation is now: holddown shift, then click the mouse - the macro will finish, withoutrecording that last click as a measurement.<BR><BR><BR>10.13 Here's the actual macro (so far)<BR><BR>procedure GetClick;<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetCursor('cross');<BR>&nbsp; &nbsp; &nbsp; repeat until button;<BR>&nbsp; &nbsp; &nbsp; if KeyDown('shift') then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit;<BR>&nbsp; &nbsp; &nbsp; end; {if}<BR>&nbsp; &nbsp; &nbsp; GetMouse(MouseX,MouseY);<BR>&nbsp; &nbsp; &nbsp; wait(0.5);<BR>&nbsp; &nbsp; &nbsp; OutOfBounds:=(MouseX&lt;0) or (MouseX&gt;width)or (MouseY&lt;0) or (MouseY&gt;height);<BR>end;<BR><BR><BR>macro 'Measure Positions v.2 [M]';<BR>var<BR>&nbsp; &nbsp; &nbsp; MouseX: integer;<BR>&nbsp; &nbsp; &nbsp; MouseY: integer;<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>&nbsp; &nbsp; &nbsp; width: integer;<BR>&nbsp; &nbsp; &nbsp; height: integer;<BR>&nbsp; &nbsp; &nbsp; OutOfBounds: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; GetPicSize(width,height);<BR>&nbsp; &nbsp; &nbsp; counter:=1;<BR>&nbsp; &nbsp; &nbsp; SetOptions('User1User2');<BR>&nbsp; &nbsp; &nbsp; SetUser1Label('Mouse X');<BR>&nbsp; &nbsp; &nbsp; SetUser2Label('Mouse Y');<BR>&nbsp; &nbsp; &nbsp; ShowResults;<BR>&nbsp; &nbsp; &nbsp; repeat<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetClick;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while OutOfBounds dobegin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Beep;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GetClick;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end; {while}<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rUser1[counter]:=MouseX;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rUser2[counter]:=MouseY;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetCounter(counter);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UpdateResults;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counter:=counter+1;<BR>&nbsp; &nbsp; &nbsp; until counter=256;<BR>end;<BR><BR><BR>10.14 Macros to save and clear the data<BR><BR>Two other small macros can be added to make the project more versatile.The &quot;Save Data&quot; macro is very simple:<BR><BR>macro 'Save Data [S]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetExport('Measurements');<BR>&nbsp; &nbsp; &nbsp; Export('Image Data');<BR>end;<BR><BR>This states that the data to be saved are in the rUser arrays,and makes the suggested file name &quot;Image Data&quot;. The&quot;Save&quot; dialogue box appears, with the &quot;Measurements&quot;radio button clicked and the file name already in place; all theuser has to do is click the &quot;Save&quot; button, and the datais saved (in delimited format, which can be loaded into Excel)in the current directory. The directory can be changed by theuser if desired.<BR><BR>The &quot;Clear All Data&quot; macro is also very simple: we useResetCounter, which sets rCount to 0, so that the ShowResultscommand actually just displays a blank window.<BR><BR>macro 'Clear All Data [C]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; ResetCounter;<BR>&nbsp; &nbsp; &nbsp; ShowResults;<BR>end;<BR><BR>This macro is really only for cosmetic purposes: the main macrois written in such a way that it automatically renews the resultsarrays when it is rerun. However, before the first click is madeon the second run, the results from the first run will still bedisplayed in the Results window, which can be offputting. It isonly when the first click is registered that the Results windowis wiped and the first new coordinates appear. So it is usefulto have this short macro available to stop things getting confused.<BR><BR><BR>10.15 An &quot;undo&quot; option<BR><BR>Much more important is an &quot;undo&quot; option. It is moreuser-friendly to build this option into the main macro itselfrather than have a separate macro. Here is the whole thing, withthe new undo option included.<BR><BR>procedure GetClick;<BR>begin<BR>&nbsp; &nbsp; &nbsp; SetCursor('cross');<BR>&nbsp; &nbsp; &nbsp; repeat until button;<BR>&nbsp; &nbsp; &nbsp; if KeyDown('shift') then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit;<BR>&nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; UndoFlag:=(KeyDown('option'));<BR>&nbsp; &nbsp; &nbsp; GetMouse(MouseX,MouseY);<BR>&nbsp; &nbsp; &nbsp; wait(0.5);<BR>&nbsp; &nbsp; &nbsp; OutOfBounds:=(MouseX&lt;0) or (MouseX&gt;width)or (MouseY&lt;0) or (MouseY&gt;height);<BR>end;<BR><BR><BR>macro 'Measure Positions v.3 [M]';<BR>var<BR>&nbsp; &nbsp; &nbsp; MouseX: integer;<BR>&nbsp; &nbsp; &nbsp; MouseY: integer;<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>&nbsp; &nbsp; &nbsp; width: integer;<BR>&nbsp; &nbsp; &nbsp; height: integer;<BR>&nbsp; &nbsp; &nbsp; OutOfBounds: boolean;<BR>&nbsp; &nbsp; &nbsp; UndoFlag: boolean;<BR>begin<BR>&nbsp; &nbsp; &nbsp; GetPicSize(width,height);<BR>&nbsp; &nbsp; &nbsp; counter:=1;<BR>&nbsp; &nbsp; &nbsp; SetOptions('User1User2');<BR>&nbsp; &nbsp; &nbsp; SetUser1Label('Mouse X');<BR>&nbsp; &nbsp; &nbsp; SetUser2Label('Mouse Y');<BR>&nbsp; &nbsp; &nbsp; ShowResults;<BR>&nbsp; &nbsp; &nbsp; repeat<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetClick;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while OutOfBounds dobegin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Beep;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GetClick;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end; {while}<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if UndoFlag then begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;counter:=counter-2;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SetCounter(counter);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UpdateResults;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;counter:=counter+1;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rUser1[counter]:=MouseX;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rUser2[counter]:=MouseY;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SetCounter(counter);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UpdateResults;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;counter:=counter+1;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end; {if}<BR>&nbsp; &nbsp; &nbsp; until counter=256;<BR>end;<BR><BR>We have a new boolean variable, UndoFlag, which has the value:<BR><BR>UndoFlag:=(KeyDown('option'));<BR><BR>which means that UndoFlag is true if the option key (which islabelled &quot;alt&quot; on the iMac) is held down when the mouseis clicked. This is a good key to use for Undo, since it is conventionallyheld down with another key to do the opposite of what that keynormally does, e.g. zoom out instead of zoom in, in both NIH Imageand Photoshop. We then use an if command to choose either thestandard &quot;add this click to the results arrays&quot; if UndoFlagis false, or to execute a new piece of code if UndoFlag is true.The latter is:<BR><BR>counter:=counter-2;<BR>SetCounter(counter);<BR>UpdateResults;<BR>counter:=counter+1;<BR><BR>This may not be obvious at first. Why do we go back two places,then show the results, then go forward one place? The answer is:for display purposes only! We could just deduct one from the counter,then re-enter the main program. This would make the next click'scoordinates overwrite the previous ones. However, we really wantto &quot;wipe&quot; the previous pair of coordinates from theResults window, to show that the Undo operation is working.<BR><BR>To do this, we need to set the counter to one less than the lastpair, then use &quot;UpdateResults&quot;, so that the resultswill only be displayed up until the penultimate pair. The lastpair of coordinates are still there - they are just not beingdisplayed! Then, after the UpdateResults command, we can increasethe counter by 1, so that it is ready to overwrite the last (andnow hidden) pair of coordinates once more. I hope this is clear!If not, it is simple to verify that it works.<BR><BR><BR>10.16 Future work<BR><BR>Think about what could make this macro even better. It could bemade more robust: if the user tries to &quot;undo&quot; beyondthe start of the rUser arrays (if he immediately uses the undooption, for example), the macro crashes. A command could easilybe added to detect this and prevent it happening.<BR><BR>One obvious idea for future development is to add a marker ofsome sort to the image, to show where the clicks actually are.Of course, this will affect the image pixels. One solution isto program in a transparent &quot;overlay&quot; which can markthe user's measurements without affecting the pixels. This hasbeen implemented in &quot;Object Image&quot; by Norbert Vischer.It's an extended version of NIH Image, available from:<BR><BR><A HREF="http://simon.bio.uva.nl/object-image.html">http://simon.bio.uva.nl/object-image.html</A><TT><BR><BR>More details are given in the last chapter. Alternatively, ifyou only need a simple image-measuring macro of some kind, ora very specialised one, why not investigate writing your own?</TT></FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor307304"></A><B><TT><FONT FACE="Courier">11.Introduction to image processing</FONT></TT></B><TT><FONT FACE="Courier"><BR><BR>11.1 The digital image concept<BR><BR>Digital images (such as those processed in NIH Image) are madeof discrete pixels. The image processing in this chapter is basicallya set of ideas for operating on the pixels that make up an image.For simplicity, we deal only with greyscale (&quot;black and white&quot;)images, since these only have a single value for each pixel (unlikecolour images). We'll learn how to access these values and modifythem, thus enabling us to do the basics of image processing.<BR><BR><BR>11.2 Regions of interest (ROIs)<BR><BR>An ROI is selected (in non-macro mode) using the mouse - ROIscan be rectangular, linear, oval, or more complex shapes. Withina macro, an ROI can be defined by specifying its coordinates andsize, using the MakeROI command:<BR><BR>macro 'Make ROI [M]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; MakeROI(0,0,100,100);<BR>end;<BR><BR>The above macro selects a rectangular ROI with its top left handcorner at (0,0) - which is the top left hand corner of the image,remember - and pixel dimensions of 100 x 100: a square. For othertypes of ROI, see the NIH Image Manual. If no ROI is explicitlyselected, the whole image is assumed to be the ROI for the purposesof the commands in the next section.<BR><BR><BR>11.3 Simple commands<BR><BR>Before getting into more complex things, there are several simplecommands that can change pixel values - AddConstant, ChangeValues,EnhanceContrast, Fill, Invert, etc. These all operate on the currentROI, and are exactly equivalent to selecting the appropriate commandsfrom NIH Image in non-macro mode. So, to invert an ROI, we canuse:<BR><BR>macro 'Invert [I]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; Invert;<BR>end;<BR><BR>This will invert the whole image if no ROI is selected, or justthe ROI if one is selected (try running it immediately after &quot;MakeROI&quot;, above). But there's no point in doing this for oneimage - we might as well just use the menu command &quot;Invert&quot;.The only justification for using a macro like this is if we needto do the same thing to a large number of files: such batch processingis covered later in this chapter.<BR><BR><BR>11.4 GetPixel and PutPixel<BR><BR>GetPixel allows us to access pixel values, one by one, and PutPixelto specify the values we want certain pixels to have. Simply enough,GetPixel(x,y) returns the value of the pixel at coordinates (x,y),and PutPixel(x,y,z) assigns the value z to the pixel at (x,y).<BR><BR>Note, however, that this is not generally a sensible way to doimage analysis. Pixel-by-pixel tinkering is very slow, and onlyworth doing if you a small number of pixels are involved. To covera whole image, pixel by pixel, it's much faster to work in rows.<BR><BR><BR>11.5 GetRow, PutRow, and the LineBuffer array<BR><BR>There can be hundreds of thousands of pixels in an image. Storingthis information needs seriously big arrays. Image pixel greyvaluescan be accessed and modified via an array called the LineBuffer,which reads one line of the image in at a time. This buffer canget very long - there is no point trying direct addressing here,like LineBuffer[6]:=34 ... we have to sort out a for loop thatwill cover the whole array. And to cover the whole image, we needto feed all of it through the LineBuffer array, line by line.This operation is conceptually simple, though it requires a lotof computer processing power. <BR><BR>We can access each pixel of an image using the GetRow command.This feeds a row of pixel values into the LineBuffer array. Thelength of the row, and its starting coordinates (from the topleft, as always) are defined in the GetRow command:<BR><BR>GetRow(x,y,length)<BR><BR>is the correct syntax, where (x,y) are the coordinates of theleft-hand end of the line of pixels, and length is its length- which must equal the total width of the image, if we want toaccess the whole image a row at a time. Once this command hasbeen executed, then LineBuffer[1] contains the greyvalue of thefirst pixel, LineBuffer[2] the second, and so on up to LineBuffer[length],which represents the final pixel.<BR><BR>We can, of course, alter the elements of LineBuffer to whatevervalues we like, cycling through them all using a for loop. Thenwe can output these new values to the image, via the &quot;mirrorimage&quot; of GetRow, which is PutRow. This has the same syntax:<BR><BR>PutRow(x,y,length)<BR><BR>places &quot;length&quot; pixels from the LineBuffer array intoa row in the current image, starting at location (x,y). As wewill be processing the whole image, without wanting to displaceanything, we will always keep x, y, and length the same for each&quot;pair&quot; of GetRow and PutRow commands.<BR><BR>One more thing we need to know is the dimensions of the image,i.e. how long is each row going to be, assuming we want to coverthe whole image, and how many rows are there, i.e. what is thevertical height of the image? We can obtain the image dimensions,in pixels, using<BR><BR>GetPicSize(width,height)<BR><BR>where width and height are in pixels. Of course, there is potentialfor confusion if more than one image is open - we must be surewe are measuring the dimensions of the right one. The simplestway to do this is to build an error-detecting command into themacro that ensures that only one image is open, i.e. that nPics=1.Alternatively, we can activate the window we want using a suitableidentifier (see later).<BR><BR><BR>11.6 Changing pixel values - two examples<BR><BR>So, it's now fairly simple to write a macro to change every pixelin an image. The example below changes every pixel to a greyvalueof 25 - a pale grey. Not much use, but it shows how the basic&quot;pixel-altering&quot; structure works, via a row-by-row approach.Note the nested for loops which run along each row, and down the&quot;column&quot; of rows that makes up the image.<BR><BR>macro 'Make All Pixels 25 [P]';<BR>var<BR>&nbsp; &nbsp; &nbsp; width: integer;<BR>&nbsp; &nbsp; &nbsp; height: integer;<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>&nbsp; &nbsp; &nbsp; counter2: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; GetPicSize(width,height);<BR>&nbsp; &nbsp; &nbsp; for counter:=0 to height do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetRow(0,counter,width);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for counter2:=1 to widthdo begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LineBuffer[counter2]:=25;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PutRow(0,counter,width);<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>It is possible to do this type of thing using columns, instead:there are equivalent GetColumn and PutColumn commands. For nowwe'll just use rows.<BR><BR>We can easily modify the above structure to change pixels howeverwe like. For example, we can generate a &quot;snowstorm&quot;by changing each pixel to a random value between 0 and 255, whichwe do using the &quot;random&quot; command:<BR><BR>macro 'Snowstorm [S]';<BR>var<BR>&nbsp; &nbsp; &nbsp; width: integer;<BR>&nbsp; &nbsp; &nbsp; height: integer;<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>&nbsp; &nbsp; &nbsp; counter2: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; GetPicSize(width,height);<BR>&nbsp; &nbsp; &nbsp; for counter:=0 to height do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetRow(0,counter,width);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for counter2:=1 to widthdo begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LineBuffer[counter2]:=(random*255);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PutRow(0,counter,width);<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>Note that LineBuffer is only &quot;designed&quot; to hold 8-bitvalues, i.e. on a scale of 0 to 255. Values outside this rangewill cause a crash. So, if you are doing calculations which couldresult in a value outside the range (e.g. adding multiple pixelvalues together, then dividing to get an average), then you mustuse intermediate variables, placing only the final averaged valueback into the LineBuffer.<BR><BR><BR>11.7 Macros in action<BR><BR>Image processing in this way is very slow. If you plan to do alot of it, then you'll save time in the long run by learning toprogram &quot;proper&quot; Pascal add-ons to NIH Image, ratherthan just macros. For now, we may find ourselves stuck with macrosthat take 10 minutes per image, or more. The best thing to dohere is to read a good book, and only look up when the macro isfinished and a new image can be got started. Think about waysto design a 'user-friendly' macro. For example, make it beep whenit is finished, then you won't need to watch the screen. <BR><BR>Another observation is useful in this case. There are two waysto run a macro: via a &quot;hot key&quot;, or using the mouseto select the macro name from the Special menu. The latter isslower, but has a (probably serendipitous) advantage that the&quot;Special&quot; title stays highlighted until the macro hasfinished (upon which it reverts to normal). This is not the casewith the &quot;hot key&quot; method. This means that the &quot;menuselection&quot; option gives a visual indicator of whether ornot the macro has finished, which is useful when you are doingsomething else, and need to know this at a glance.<BR><BR>If you have a lot of images to process, it's worth looking atthe batch processing method (see later in this chapter).<BR><BR><BR>11.8 To repeat two earlier points<BR><BR>Remember that you don't need to write a macro if (1) NIH Imagecan already do the job you need, or (2) someone else already wrotea macro that can do it. Let's take an example. <BR><BR>I wanted to average some images. I was fairly sure that NIH Imagecould do this without a macro - and it can. It is possible toload a whole set of images into NIH Image, then to convert theminto a &quot;stack&quot;. Then, the &quot;Average&quot; command(under the &quot;Stack&quot; menu) produces an arithmetic averageof the images in the stack - exactly what I wanted.<BR><BR>Unfortunately it only works with images up to 2048 pixels wide- and mine were 2592 pixels wide. I was also limited by memory- even giving NIH Image 128MB only allowed ten separate imagesto be loaded to the stack, and loading in all 47 of my imageswould have required c. 450MB ... and I only had 196MB of RAM intotal! So in this case, I had to write a macro to get round thelimits of NIH Image - and it was slow, and inefficient. But evenso, it only took me a few days to do the whole operation.<BR><BR>I won't bother with the whole code for the averaging macro here.The core is very simple - row by row, use GetRow to get the LineBuffervalues from each image and add them to the overall average, thencreate the average image using PutRow. But there are two moreuseful points to cover.<BR><BR><BR>11.9 Selecting among multiple image windows<BR><BR>How can we switch between different image windows when we havemore than one image open at the same time? The easiest way todo this is using the SelectWindow command:<BR><BR>macro 'Select Window [S]';<BR>begin<BR>&nbsp; &nbsp; &nbsp; SelectWindow('Test Image');<BR>end;<BR><BR>This macro will select the window called &quot;Test Image&quot;- if there isn't a window called this, then a 'Window Not Found'error is returned, so we must be sure that the window is actuallythere! Selecting a window brings it to the top of the desktopand makes it the &quot;Active Window&quot; - you can tell theactive window because it has horizontal lines either side of thetitle in the title bar. Many macro operations (e.g. the Writecommand) operate on the active window, so if we have more thanone window open, we need to make sure that the active window isthe right one to operate on.<BR><BR>If we don't know the image's exact name, we use the &quot;PIDNumber&quot;function, which is more versatile, since it uses the ORDER OFLOADING to assign each image window a different, permanent number.Since PIDNumber is a function, it returns a numerical value (abit like nPics), so we must assign its value to a variable:<BR><BR>macro 'PIDNumber';<BR>var<BR>&nbsp; &nbsp; &nbsp; PicID: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; PicID:=PIDNumber;<BR>&nbsp; &nbsp; &nbsp; PutMessage(PicID);<BR>end;<BR><BR>If we run the above macro with no image open, we just get a PicIDvalue of zero. With one image, we get -1. The way the assignmentworks is that the first image to be loaded gets -1, the second-2, the third -3, and so on. These numbers are permanent, andthey are not reset by other images being closed or re-opened.Consider carefully how the assignment works. Let's say we openimage A first, then image B, then image C. Our PIDNumbers are-1, -2, and -3. We then close A and B, so that we only have Copen. Its PIDNumber stays at -3. We then reopen image B, thenreopen image A. Image B now has the PIDNumber -4, and image Agets -5. And so on - you can't change the PIDNumber of an imagewithout closing it and reloading it. I hope this is clear.<BR><BR>Now, the function PIDNumber only returns one value at a time -the PIDNumber of the active window, the window at the top of thedesktop with the lines on its title bar. There can only ever beone active window. A newly-loaded image will always be the activewindow.<BR><BR>So, how do we move between windows within a macro, once we knowwhich PIDNumber we want? There are two options. The SelectPic(x)command selects the window with PIDNumber x and brings it to thetop of the screen. The ChoosePic(x) command is identical, butdoesn't move the selected image to the top - technically, it &quot;selects&quot;the window without &quot;activating&quot; it. The latter is moreuseful in macros where different images need to be accessed, sincewe don't want the screen forever flicking back and forth betweenthe different windows being activated.<BR><BR>The golden rule is always to capture the PIDNumber of an imagewhen you KNOW that it is the active image (e.g. when it has justbeen loaded up), and then to put this value into a variable witha meaningful name (like 'ThirdImagePID'), then you can switchto it later, whenever you like, safe in the knowledge that thePIDNumber never changes.<BR><BR><BR>11.10 Batch processing<BR><BR>This is one of the most time-saving capabilities of macros. Anyoperation, no matter how simple, is worth coding a macro for ifyou have to do it to 1,000 images, because you can batch-processthe whole lot in one go without having to load them in individually.In general, if you have so many images that it's worthwhile writinga batch-processing routine for them, then it won't be feasibleto type in all the filenames - instead, you'll need to generateall the filenames required. The easiest way to do this is to have&quot;progressively numbered&quot; filenames, which can be generatedusing a for loop. This is the crux of batch-processing: generatingthe correct list of filenames. The rest is simple: we use &quot;open('filename')&quot;to open each image in turn, then use a procedure to process it,then save it with &quot;save&quot; and close the window with &quot;close&quot;.<BR><BR>For example, let's say we have five images, with filenames &quot;Image1&quot;through &quot;Image5&quot;. We can generate these file names byhaving a for loop running from one to five and adding this numberto the string &quot;Image&quot;. Look at the following macro:<BR><BR>macro 'Load Five Images [L]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; for counter:=1 to 5 do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; open('Image',counter:1:0);<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>See how we use &quot;counter&quot; to generate the numbers? Notethat we have to specify &quot;counter:1:0&quot; as the suffixin the &quot;open&quot; command, to remove any spaces before thenumber. Running the macro does bring up a dialogue box, for thefirst file, but when &quot;Open&quot; is clicked, the remainderof the files are also loaded without any more dialogue boxes.This will only work as long as all the files are in the same directory;if they are not, then the full path needs to be specified in themacro. This would be something like 'MacintoshHD:Images:New:Image1'instead of just the filename.<BR><BR>To load in and process all five images, we just add the commandsdescribed above. The macro below uses &quot;Invert&quot; as anexample process:<BR><BR>macro 'Invert Five Images [I]';<BR>var<BR>&nbsp; &nbsp; &nbsp; counter: integer;<BR>begin<BR>&nbsp; &nbsp; &nbsp; for counter:=1 to 5 do begin<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; open('Image',counter:1:0);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Invert;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save;<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close;<BR>&nbsp; &nbsp; &nbsp; end;<BR>end;<BR><BR>Once the initial &quot;Open&quot; is clicked in the dialogue box,this macro loads each image in turn, inverts it, saves the change,and closes it. Simple really.<BR></FONT></TT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><TT><FONT FACE="Courier"><BR></FONT></TT><A NAME="anchor308372"></A><B><TT><FONT FACE="Courier">12.Where next?</FONT></TT></B><TT><FONT FACE="Courier"><BR><BR>12.1 Doing more things with macros<BR><BR>Study the NIH Image Manual and &quot;Inside NIH Image&quot;, andexperiment with the list of macro commands. This will greatlyincrease the range of things that you can do with macros. Lookonce more at the supplied macros, too. There is also some specificliterature available for different applications of NIH Image,e.g. confocal microscopy, gel analysis, etc. See the NIH Imagehome page at<BR><BR></FONT></TT><FONT FACE="Courier"><A HREF="http://rsb.info.nih.gov/nih-image/">http://rsb.info.nih.gov/nih-image/</A><TT><BR><BR>Information of all kinds is also available on the NIH Image mailinglist. Details are available at<BR><BR></TT><A HREF="http://rsb.info.nih.gov/nih-image/list.html">http://rsb.info.nih.gov/nih-image/list.html</A><TT><BR><BR>The list archives are stored at <BR><BR></TT><A HREF="http://list.nih.gov/archives/nih-image.html">http://list.nih.gov/archives/nih-image.html</A><TT><BR><BR><BR>12.2 Better programming<BR><BR>Learning the basics of good programming strategy is useful forwriting complex macros. For example, splitting a long macro intomanageable procedures and functions, and testing these thoroughlybefore putting the whole thing together. The overall structureof a macro can also be tested, even before the component partsare finished, by writing a &quot;framework&quot; macro which showshow it all fits together. For the best results, seek to combinethe &quot;bottom up&quot; and &quot;top down&quot; approaches.Don't be reluctant to try out different commands just to see whatwill work - you can't harm the computer. And remember, good programmersmodify what they already have, and don't write what they don'tneed to. Read some books on general computer programming.<BR><BR><BR>12.3 Modified versions of NIH Image<BR><BR>The open source code of NIH Image promotes the develop of &quot;evolved&quot;versions with extra capabilities. One I use often is &quot;ObjectImage&quot;, which provides a transparent overlay for markingmeasurements on (among many other features). It is available from<BR><BR></TT><A HREF="http://simon.bio.uva.nl/object-image.html">http://simon.bio.uva.nl/object-image.html</A><TT><BR><BR>There are many others which can be downloaded from several sites,including<BR><BR></TT><A HREF="ftp://ftp.gwdg.de/pub/macintosh/nih-image/">ftp://ftp.gwdg.de/pub/macintosh/nih-image/</A></FONT><BR><FONT FACE="Courier"><A HREF="http://www.ccp14.ac.uk/ccp/ccp14/ftp-mirror/nih-image/pub/nih-image/">http://www.ccp14.ac.uk/ccp/ccp14/ftp-mirror/nih-image/pub/nih-image/</A><TT><BR><BR>See if one of these has the capabilities you need. Also availableare lots of user-programmed macros.<BR><BR><BR>12.4 Modifying NIH Image itself<BR><BR>Modifying the Pascal code that comprises NIH Image itself is away to write much faster and more powerful macros. These obviouslyneed to be written in proper Pascal, not the miniature versionthat we've been discussing. The NIH Image source code is availablefrom the NIH Image home page. Some details of working in Pascal,within NIH Image, are in &quot;Inside NIH Image&quot;, also availablefrom the NIH Image home page.<BR><BR>To learn Pascal, try &quot;Oh! Pascal!&quot; by Doug Cooper -the most accessible book I've found - or any equivalent (one iscalled &quot;Learn Pascal in Three Days&quot;, if you're reallyshort of time (!)). One Pascal compiler for the Mac is THINK Pascal,available from<BR><BR></TT><A HREF="http://www.lysator.liu.se/~ingemar/tp45d4/think.html">http://www.lysator.liu.se/~ingemar/tp45d4/think.html</A><TT><BR><BR>And bear in mind that the reason for all the development activityis the &quot;open source&quot; nature of NIH Image. Read moreabout open source programs at the Open Source Initiative at </TT><AHREF="http://www.opensource.org/">www.opensource.org</A><TT>.<BR><BR><BR>12.5 More on image analysis<BR><BR>A good book on general image analysis is &quot;The Image ProcessingHandbook&quot; by John C. Russ. There are many others. Image analysis(and by extension, NIH Image) has a vast range of potential applications.The only limit is your ingenuity.</TT></FONT></P><P><FONT FACE="Courier"><HR ALIGN=LEFT></FONT></P><P><A HREF="#anchor290977"><U><TT><FONT COLOR="#0000ff" FACE="Courier">Returnto Top</FONT></TT></U></A></BODY></HTML>